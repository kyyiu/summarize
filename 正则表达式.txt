runoo+b 可以匹配runoob runooob runoooooob等 +号代表前面的字符必须至少出现一次(一次或多次)

runoo*b 可以匹配 runob runoob runoooob等 *号代表前面的字符可以不出现，也可以只出现一次或者多次(0，1，或者n次)

colou?r 可以匹配 color 或者colour ?号代表前面的字符最多只可以出现一次(0,或者1次)

普通字符
包括没有显示指定为元字符的所有可打印和不可打印字符，这包括所有大写和小写字母，所有数字标点符号和一些其他符号
字符    描述
[ABC]  匹配[...]中的所有字符，例如[aeiou] 匹配字符串‘google runoob taobao’中的所有eoua字母  /[aeiou]/g
[^ABC] 匹配除了[...]中所有的字符
[A-Z]  表示一个区间，匹配所有大写字母
.      匹配除了换行符（\n,\r）之外的任何单个字符，相当于[^\n\r]
[\s\S] 匹配所有，\s是匹配只有空白符，包括换行，\S非空白符，包括换行
\w     匹配字母，数字，下划线 等价于[A-Za-z0-9]  /\w/g

特殊字符
$ 匹配输入字符串的结尾位置
() 标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用
[ 标记一个中括号表达式的开始
^  匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合
{ 标记限定符表达式的开始
| 指明两项之间的一个选择

限定符
指定正则表达式的一个给定组件必须要出现多少次才能满足匹配，有*+?{n}{n,}{n,m}共6种
* 匹配前面的子表达式0或者多次 例如 zo* 可以匹配z，zoo等 等价于{0,}
+ 匹配前面的子表达式一次或者多次 例如 zo+ 可以匹配zo zoo 等价于{1,}
? 匹配前面的子表达式0或者1次 例如 do(es)? 可以匹配do，does，等价于{0,1}
{n} n是一个非负整数，匹配确定的n次，例如o{2}不能匹配bob中的o，但是能匹配food中的两个o
{n,} n是一个非负整数，至少匹配n次，例如o{2,}不能匹配bob，但是能匹配foooood中的所有o，o{1,}等价于o+，o{0,}等价于o*
{n,m} 最少匹配n次且最多匹配m次， o{1,3}将匹配fooooood中的前三个o，o{0,1}等价于o？注意逗号和两个数之间不能有空格

例子 以下正则表达式匹配一个正整数[1-9]设置第一个数字不是0，[0-9]*表示任意多个数字
/[1-9][0-9]*/
不能匹配到第一个是0的
021 不能匹配
129900 可以匹配

*和+限定符都是贪婪的，因为他们会尽可能的匹配文字，只要在他们后边加上一个？，就可以实现非贪婪
例如
<h1>xxx</h1>
/<.*>/ 将会匹配整个字符串
/<.*?>/将只匹配到<h1>  也可以使用/<\w+?>/匹配<h1>


定位符
定位符能够将正则表达式固定到行首或者行尾，他们还能让我们将创建这样的表达式，这些表达式出现在一个单词内，在一个单词的开头
或者一个单词的结尾
定位符原来描述字符串或者单词的边界^,$分别指字符串的开始与结束，\b描述单词的前或后边界,\B表示非单词边界

^ 匹配输入字符串的开始位置
$ 匹配输入字符串的结束位置
\b 匹配一个单词边界，即字与空格间的位置
\B 非单词边界匹配

注意
不能将限定符与定位符一起使用，由于在紧靠换行或者单词边界的前面或者后面不能有一个以上位置，因此不允许诸如^*之类的表达式
若要匹配一行文本开始处的文本，在正则表达式的开始使用^，不要将这个字符与中括号表达式内的用法混淆
若要匹配一行文本的结束处的文本，在正则表达式的结束处使用$字符
若要搜索直接标题时使用定位点，下面的正则表达式匹配一个章节匹配，该标题只包含两个尾随的数字，并且出现在行首
/^Chapter [1-9][0-9]{0,1}/
真正的章节标题不仅出现行的开始处，而且他还是该行中仅有的文本，它即出现在行首又出现在同一行的结尾。
下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用，通过创建只匹配一行文本的开始和结尾表达式就可以做到
/^Chapter [1-9][0-9]{0,1}$/

匹配单词边界有些不同，但是给正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置，非单词边界是任何其他位置。
下面匹配单词Chapter开头三个字符，因为这三个字符出现在单词边界后面
/\bCha/

\b字符的位置非常重要，如果位于匹配的字符串的开始，它在单词的开始处查找匹配项
如果位于字符串的结尾，他在单词的结尾处查找匹配项
例如，下面的表达式匹配单词Chapter中的字符串ter，因为它出现咋子单词边界的前面
/ter\b/
下面的表达式匹配Chapter中的字符串apt，但是不匹配aptitude中的字符串apt
/\Bapt/
\B非单词边界运算符，前者在非边界，后者在单词边界

选择
用()将所有现在想括起来，相邻的选择项之间用|分割
()表示捕获分组，()会把每个分组里的匹配的值保存起来，多个匹配值可以通过数字n来查看(n是一个数字，表示第n个捕获组的内容)
例如，匹配以一个数字开头多个字母结尾
/([0-9])([a-z]+)/



前置约束存在 ?=
例如, 表达式 [T|t]he(?=\sfat) 匹配 The 和 the，但是他们后面要跟着空格和fat
即我们匹配的是The fat和the fat

前置约束排除 ?!
和前置存在相反就是匹配the和The 后面不跟着空格和fat的

前置约束可以理解为要确定去匹配出来的字段在后面的一些其他约束条件，使得到的字段更精确

后置约束存在 ?<=
(?<=[T|t]he\s)(fat|mat) 匹配的是fat或者mat，但是前面要跟着The空格或者the空格
注意匹配的结果里面没有The 或者 the
比如The fat cat on the mat
匹配的就是fat和mat

后置约束排除 ?<!
(?<![T|t]he\s)(cat)匹配cat前面没有The或者the的cat
The cat sat on cat
匹配第二个cat

后置约束可以理解为要确定去匹配出来的字段在前面的一些其他约束条件，使得到的字段更精确
或者说将匹配的结果进一步筛选，通过这个约束进行