[100,101,045,021]
1.根据个位[[100],[101, 21],[],[],[],[45]]
2.从左到右倒出来[100,101,21,45]
3.根据十位[[100,101],[],[21],[],[45],[]]
4.从左到右倒出来[100,101,21,45]
5.根据百位[[21,45],[100,101]]
6.从左到右倒出来[21,45,100,101]

daixSort(arr) {
	if(arr==null || arr.length<2) {
		return
	}
	radixSortMain(arr, 0, arr.length-1,maxbits(arr));
}

// 最多有多少位数
maxbits(arr) {
	let max = number.MAX_VAlue
	for(let i = 0; i< arr.length;i++) {
		max = Math.max(max,arr[i])
	} 
	let res = 0;
	while(max !=0) {
		res++
		max/=10
	}
	return res
}

radixSortMain(arr, L, R, digit) {
	// digit最大的数有多少十进制位
	const radix = 10 // 以10为基底
	let i = 0
	let j = 0
	const bucket = []
	for (let d = 1; d<=digit;d++) { //有多少位就进出几次桶
		// 10个空间
		// count[0] 当前位是0的数字有多少个
		// count[1] 当前位是0和1的数字有多少个
		// count[i] 当前位是0~i的数字有多少个
		const count = [] // 0~9
		for(i = L, i<=R;i++) {
			j = getDigit(arr[i], d) // d如果是1取出个位，是2取出十位
			count[j]++
		}
		for(i = 1;i<radix;i++) {
			// 累加和,在某位上小于等于i的数有多少个
			// 累加和形成片区
			count[i] = count[i] + count[i-1]
		}
		// 从右往左遍历，因为要符合上面形成的片区
		for(i=R;i>=L;i--) {
			j=getDigit(arr[i], d) // 拿到当前的数
			bucket[count[j]-1] = arr[i] // 填到对应的位置
			count[j]--
		}
		// 上面执行完，相当于出桶了
		// 维持最新状态
		for(i=L,j=0;i<=R;i++,j++) {
			arr[i] = bucket[j]
		}
	}
}

getDigit(x, d) {
	return ((x/(Math.pow(10,d-1)))%10)
}



[[0的片区],[1的片区]...[9的片区]]
[11,21,31,1,40,20,35]
先看个位
count = [2,6,6,6,7,7...]
小于等于0的有两个
小于等于1的有6个
小于等于5的有7个
从右边开始遍历
在下标为6的地方插入35
下标为1的地方插入20
下标为0的地方插入40
下标为5的地方插入1
...
倒出来是
[40,20,  11,21,31,1,  35]
从左往右遍历是
[20,40, 1,31,21,11,35]

看十位
[1, 2, 4,6,7,7,7,7]
小于等于0的有1个
小于等于1的有2个
小于等于2的有4个
小于等于3的有6个
小于等于4的有7个
从右边开始遍历
十位是3，count[3]为6，所以在辅助数组下标为5的地方插入35
01十位为0，。。。在下标为0的地方插入1
31十位为3...在下标为4的地方插入31
21十位为2。。。在下标为3的地方插入21
...
[1,11,20,21,31,35,40]