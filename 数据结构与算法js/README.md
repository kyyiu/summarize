### 数据结构是在计算机中存储和组织数据的方式
### 算法 一个有限指令集，每条指令的描述不依赖于语言 接收一些输入（一些情况不需要）  产生输出  一定在有限步骤后终止

### 栈结构 stack
### 队列结构 queue
### 链表
### 集合 无序 不重复
### 字典
### 哈希表
  1. 哈希化： 将大数字转换成数组范围内下标的过程
  2. 哈希函数： 通常会将单词转换成大数字，大数字在进行哈希化的代码实现放在一个函数中
  3. 哈希表： 最终将数据插入到的这个数组对这个结构的封装
  4. 发生冲突（地址重复）解决方法
    1. 链地址法,在每个数组单元再放一个数组或链表存放重复数据
	2. 开放地址法,寻找空白单元格添加重复的数据
	  1. 线性探测 会发生聚集
	  2. 二次探测
	  3. 再次哈希化

### 树结构
  1. n格节点构成的有限集合，n=0时空树
  2. 对任何非空树，
    1. 根用r表示
	2. 其余节点可分为m个互不相交的有限集T1，T2.。。。Tm其中每个集合本身又是一个树 --子树
	3. 节点的度（degree） 节点的子树个数
	4. 树的度 树的所有节点中最大的度数
	5. 叶节点 度为0的节点
	6. 父节点 有子数的节点，其子数的根节点是父节点
	7. 子节点 若a是b的父节点，则b是a的子节点
	8. 兄弟节点 同一父节点的各节点彼此是兄弟节点
	9. 路径和路径长度： 从节点n1到nk的路径为一个节点序列n1，n2.。。nk，ni是ni+1的父节点，路径所包含边的个数为路径的长度
	10. 节点的层次 规定根节点在1层，其他的层数 是其父节点的层数+1
	11. 树的深度 树种所有节点中的最大层次是这个树的深度
  3. 二叉树 每个节点最多只有两个节点
    1. 一个二叉树第i层的最大节点数为 2^(i-1), i>=1
	2. 深度k的二叉树最大节点总数 2^k-1 ,k>=1
	3. 任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么两者关系满足n0 = n2 +1
	4. 完美二叉树
	5. 完全二叉树
	6. 二叉搜索树 bst  binary search tree
	  1. 如果不为空满足以下特性
	  2. 非空左子树的所有键值小于其根节点的键值
	  3. 非空有子树的所有键值大于其根节点的键值
	  4. 左右子树本身也都是二叉搜索树
	  5. 缺陷是插入有序数据会变成非平衡树，用avl树和红黑树解决
	7. 红黑树
	  1. 节点是红色或者黑色
	  2. 根节点是黑色
	  3. 每个叶子节点都是黑色的空节点（NIL节点）
	  4. 每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）
	  5. 从任一节点到其每个叶子的所有路径都包含相同的黑色节点
	  6. 以上规则保证从根到叶子节点的最长路径不超过最短路径的两倍
	  7. 使用变色和旋转维持规则
	  8. 右旋转（顺时针） 使父节点被自己的左孩子取代，自己成为自己的右孩子
	  8. 左旋转（逆时针）使父节点被自己的右孩子取代，自己成为自己的左孩子
	  8. 插入的节点 的 父红叔红祖黑 变成 父黑叔黑 祖红
	  9. 插入的节点是左儿子 父红叔黑祖黑 按步骤 1 父黑 2祖红 3以祖节点为根右旋转
	  10. 插入的节点是右儿子 父红叔黑祖黑 按步骤 1 以父节点为根左旋转（将父节点整体当新插入的红色节点考虑） 2自己变成黑色 3祖变红 4以祖为根右旋转


### 图论
  * 实现
    1. 邻接矩阵
	2. 邻接表 类似 哈希表
	3. 遍历 bfs 广度优先搜索  dfs 深度优先搜索
	4. bfs 基于队列，顶点先被探索
	5. dfs基于栈或者递归，通过将顶点放在栈中顶点是沿着路径被探索的存在新的相邻顶点就去访问

### 排序算法
  * 大O表示法
  * 常见的O（1）常数的
  * O（log（n）） 对数的
  * O（n）线性的
  * O（nlog（n））线性和对数乘积
  * O（n^2）平方
  * o（2^n）指数的
  * 推导方式 1.用常量1取代运行时间中的所有加法常量 2在修改后的运行次数函数中，值保留最高项 3如果最高不存在且不为1则去除与这个项相乘的常数
  * 简单排序： 冒泡 选择 插入
  * 高级排序： 希尔 快速