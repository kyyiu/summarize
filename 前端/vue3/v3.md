# ref系列
1. ref
类似react的useState, 推荐绑定基本类型,因为复制类型也是内部转换到reactive去的
注意: ref的更新会造成shallowRef的视图更新，因为ref中有shallowRef的依赖，更新时会触发
2. shallowRef
节省性能的ref，但是如下使用不会触发响应式
const a = shallowRef({
    name: 'a'
})
a.value.name = 'b'
3. triggerRef
强制更新,可以使上面的更新实现如下
triggerRef(a)
4. customRef
使用
function MyRef<T>(v: T) {
    return custoRef((trank, trigger) => {
        return {
            get() {
                trank()
                return v
            },
            set(newVal: T) {
                v = newVal
                trigger()
            }
        }
    })
}
let my = MyRef<string>('日天')


# reactive, 推荐绑定复制类型
```javascript
import { reactive, shallowReactive } from 'vue'
let msg = reactive([])
let obj = reactive({
    name: 'aa'
})
// 可以直接修改
obj.name = 'bb'
// 对于数组不要直接赋值，像msg=[1,2], 这样会破坏原来的响应式
// 应该如此
msg.push(...[1,2])

// shallowReactive只会把第一层弄成响应式,更深层次不会更新到dom，值是会修改的
// 更准确的说是在挂载前修改会失效，但是挂载dom后，深层次不会更新
```


# computed
```javascript
import { computed, ref } from 'vue'
let FN = ref('')
let LN = ref('')

// 使用方法1
const name = computed(()=>{
    return FN.value + LN.value
})

// 使用方法2
const name2 = computed({
    get(){
        return FN.value + LN.value
    }
    set(){
        FN.value + LN.value
    }
})

input v-model="FN"
input v-model="LN"
div {{name}} /div

```

# watch
```javascript
import { ref, watch } from 'vue'
let msg = ref('')
let msg2 = ref('')
let msg3 = reactive({
    a:{
        b:{
            c: 'c'
        }
    },
    a2: 'a2'
})

// 监听一个
watch(msg, (newV, oldV) => {

})
// 监听多个
watch([msg, msg2], (newV, oldV) => {

})
// 深度监听，有个bug是newV和oldV的值一样
watch([msg, msg2], (newV, oldV) => {

}, {
    // 如果是reactive，这个可写可不写，ref必须写
    deep: true
})

// 监听单一属性
watch(() => msg3.a2, (n,o)=>{})
```


# 高级监听器(watchEffect)
```javascript
import { watchEffect, ref } from 'vue'
let msg = ref('')
let msg2 = ref('')

// endWatch函数调用后将停止监听
const endWatch = watchEffect((oninvalidate)=>{
    oninvalidate(() => {
        // 监听的数据改变之前做一些事情
    })
    console.log(msg.value) // 此时就监听了msg
}， {
    flush: 'post' , // 组件更新后执行，还有pre， sync两个选项
    onTrigger(e) {

    }
})

```

# 组件和生命周期
```javascript
import {
    onBeforeMount, // 创建之前
    onMounted, // 创建完成
    onBeforeUpdate, // 更新之前
    onUpdated,  // 更新之后
    onBeforeUnmount,  // 卸载之前
    onUnmunted // 卸载完成
} form 'vue'
console.log('setup第一')
onBeforeMount(()=>{
    // 创建之前
})
```