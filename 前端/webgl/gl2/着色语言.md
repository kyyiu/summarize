# 数据类型   
## 标量    
1. 布尔型——bool;  
bool b;            //声明一个布尔型变量
2. 有符号整型/无符号整型——int/uint
```c
整型分为无符号和有符号两种类型，在默认情况下声明的整型变量都是有符号类型，用int来表示。整型用来声明一个单独的整数，其值可以为正数、负数和0，而无符号整型则不能用来声明负数。着色语言中的整型较为特殊的方面是其应保证最少支持32位精度。实际开发时要注意，运算不要超出正常范围，否则很有可能产生溢出，产生不可预测的错误。

着色语言中的整数也可以像C语言中的那样，不仅可以用十进制表示，有时为了使表达更加便捷还可以使用八进制或者十六进制等不同进制来表示，基本用法如下所示。

1    int a = 7;          //用十进制表示的整型
2    uint b=3u;          //无符号十进制
3    int b = 034;        //以0开头的字面常量为八进制，代表十进制的28
4    int c = 0x3C;       //以0x开头的字面常量为十六进制，代表十六进制的57
```
3. 浮点数——float    
```c
着色语言中的浮点型用来声明一个单独的浮点数。由于着色语言并不没有像C/C++那样提供多种不同精度的浮点数，所以在代码中赋值浮点数部分时只要给出具体值即可。系统会将所有浮点数的都视为浮点型进行处理，无须再使用后缀来说明精度。

1    float f;             //声明一个浮点型的变量
2    float g = 3.0;       //在声明变量的同时为变量赋初值
3    float h, I;          //同时声明多个变量
4    float j, k = 3.12, l;  //声明多个变量时，可以为其中某些变量赋初值
5    float s=3e2;           //声明变量，并赋予指数形式的值，表示3乘以10的平方
需要注意的是，由于WebGL的着色语言没有采用C/C++语言的方式来提供多种不同精度的浮点数，因此代码中的字面常量就不需要使用后缀来说明精度了，只要给出值即可。
```

## 向量   
```
着色语言中，向量可以看作由同样类型的标量组成的数据类型。其中标量的基本类型也分为bool、int及float型3种。每个向量由两个、3个或4个相同的标量组成
```

```c
声明向量类型变量的基本语法如下。

1    vec2 v2;                            //声明一个包含两个浮点数的向量
2    ivec3 v3;                           //声明一个包含3个整数的向量
3    uvec3 vu3    ;                      //声明一个包含3个无符号整数的向量
4    bvec4 v4;                           //声明一个包含4个布尔数的向量
```

```c
向量在着色器的开发中占有不可撼动的地位。向量可以很方便地对颜色、位置、纹理坐标等由多个分量组成的量进行操作。有时需要对其中的某一个分量进行操作，向量也可以完美地解决此问题。基本语法为“<向量名>.<分量名>”。主要用法如下。

用一个向量表示颜色信息时，可以使用r、g、b、a这4个分量名，其分别代表红、绿、蓝、透明度4个色彩通道。对某个分量进行操作时，只需要用上述语法指明向量的分量再进行操作即可。具体用法如下。
1    aColor.r = 0.5;                        //给向量aColor的红色通道分量赋值
2    aColor.g = 0.7;                        //给向量aColor的绿色通道分量赋值

如果进行操作的向量为四维的，则可以使用的分量名为r、g、b、a；如果向量为三维的，则可以使用的分量名为r、g、b。如果向量为二维的，则仅可以使用r、g两个分量。
```
```c
如果用向量来表示物体的位置坐标时，可以使用此向量的x、y、z、w这4个分量名，其分别代表x轴、y轴、z轴分量及w值。若要对其进行赋值，则用“=”连接分量和数值即可，具体用法如下。
1    aPosition.x = 57.1;                    //给向量aPosition的x轴分量赋值
2    aPosition.z = 32.8;                    //给向量aPosition的z轴分量赋值
```
```c
当将一个向量看作纹理坐标时，可以使用s、t、p、q这4个分量名，其分别代表纹理坐标的不同分量。若向量是四维的，则可以使用的分量名为s、t、p、q；若向量为三维的，则可以使用的分量名为s、t、p；若为二维的，则可以使用s、t两个分量。其具体用法如下。
1    aTexCoor.s = 0.24;                        //给向量aTexCoor的s分量赋值
2    aTexCoor.t = 0.71;                        //给向量aTexCoor的t分量赋值
在访问向量中的各个分量时不但可以采用“.”加上不同分量名的方法，还可以将向量看作一个数组，指明向量名称并找出对应下标作为后缀来进行访问。具体用法如下。

1    aColor[0]=0.6;                           //给向量aColor的红色通道分量赋值
2    aPosition[2]=48.3;                       //给向量aPosition的z轴分量赋值
3    aTexCoor[1]=0.34;                        //给向量aTexCoor的t分量赋值
```

## 矩阵
```c
矩阵类型的基本用法如下。

1    mat2 m2;                                      //声明一个mat2类型的矩阵
2    mat3 m3;                                      //声明一个mat3类型的矩阵
3    mat4 m4;                                      //声明一个mat4类型的矩阵
4    mat3x2 m5;                                    //声明一个mat3x2类型的矩阵

着色语言的矩阵类型是由多个向量按照列顺序进行组织的。在对矩阵进行访问时，可以将矩阵视为列向量的数组。例如：matrix为一个mat4类型的矩阵，matrix[2]代表该矩阵的第3列，其为一个vec4；matrix[2][2]指的是第3列向量中的第3个分量
```

## 采样器
```
采样器是着色语言中一种特殊的基本数据类型，专门用来执行纹理采样的相关操作。在片元着色器中，采样函数需要通过采样器变量来访问纹理单元。一般情况下，一个采样器变量代表一幅或一套纹理贴图.

采样器变量不能在着色器中进行初始化。一般情况下采样器变量都用uniform 限定符来修饰，从宿主语言（如C++、Java）接收传递至着色器的值。此外，采样器变量也可以用作函数的参数，但是作为函数参数时不可以使用out或inout修饰符来修饰
```

## 结构体   
```c

在着色语言中为了给开发人员更多的开发空间，还提供了类似C语言中的用户自定义结构体。同样也是使用struct关键字进行声明，基本用法如下所示。

1    struct info{                       //对名称为info的结构体进行声明
2        vec3 color;                    //代表颜色的向量
3         vec3 position;                //代表位置的向量
4         vec2 textureCoor;             //纹理坐标的向量
5    }
自定义结构体声明完成后，如果开发人员需要使用此结构体，则同使用内建数据类型那样直接声明即可。具体用法如下面代码所示。

info CubeInfo;                        //声明了一个info类型的变量CubeInfo

在着色语言中，结构体的其他用法与C语言中的结构体相同
```

## 数组
```c
着色语言允许开发人员声明任何类型的数组。对数组进行声明的方法主要有两种，具体代码如下。

（1）声明数组的同时指定数组的大小。

vec3 position[20];                    //声明了一个包含20个vec3的数组，索引从0开始。
（2）在声明数组时，也可以不指定数组的大小，但是这时必须符合下列两种情况之一。

引用数组之前，要再次对数组进行声明，并指定数组的大小。具体代码如下所示。
1    vec3 color[];                    //声明了一个大小不定的vec3型数组
2    vec3 color[3];                   //再次声明该数组，并且指定大小
代码中访问数组的下标是常量，编译器会自动创建适当大小的数组，使得数组足够存储编译器看到的最大索引值对应的元素，代码如下。
1    vec3 position[];                        //声明了一个大小不定的vec3型数组
2    position[4] = vec3(4.0);                //position需要为一个大小为5的数组
3    position[16] = vec3(3.0);               //position需要为一个大小为17的数组
```

## 空类型 
```c
空类型使用void来表示，仅用来声明没有任何返回值的函数。例如在顶点着色器以及片元着色器中必须存在的main函数就是一个返回值为空类型的函数，代码如下所示。

1   void main()                        //声明一个空返回值类型的main方法
2   {  //函数的具体操作略 }
```

# 变量命名建议
```
1. 由于系统中有很多内建变量都是以“gl”作为开头的，因此用户自定义的变量不允许使用“gl”作为开头，从而将自定义变量和内建变量区分出来。
2. 使用驼峰命名
```

# 变量初始化的规则
```c
由于着色语言中的变量初始化规则基本承袭自C语言，所以C语言中的大部分语法规则在着色语言中同样适用，但是也有一些不同，基本规则如下所示。

常用初始化方式：变量可以在声明的时候就进行初始化。
int a=5,b=6,c;                    //声明了整型变量a、b与c，同时为a与b变量赋初值
用const限定符修饰的变量必须在声明的时候进行初始化。
const float k=3.0;                //在声明的时候初始化
全局的输入变量、一致变量以及输出变量在声明的时候一定不能进行初始化。
1    in float angleSpan;   //不可对全局输入变量进行初始化
2    uniform int k;        //不可对一致变量进行初始化
3    out vec3 position;    //不可对全局输出变量进行初始化
```

# 初始化技巧
```c
1    float a=56.3;         //声明了浮点变量a并赋初值
2    float b=23.4;         //声明了浮点变量b并赋初值
3    vec2 va=vec2(6.3,4.5);//声明了二维向量va并赋初值
4    vec2 vb=vec2(a,b);    //声明了二维向量vb并赋初值
5    vec3 vc=vec3(vb,95.5);//声明了三维向量vc并赋初值
6    vec4 vd=vec4(va,vb);  //声明了四维向量vd并赋初值 
7    vec4 ve=vec4(3.2);    //声明了四维向量ve并赋初值，相当于vec4(3.2,3.2,3.2,3.2)
8    vec3 vf=vec3(ve);     //声明vf并初始化，相当于ve3（3.2,3.2,3.2）舍弃了ve的第4个分量


// 矩阵
1    float a=6.3;                                //声明了浮点变量a并赋初值
2    float b=11.4;                               //声明了浮点变量b并赋初值
3    float c=12.5;                               //声明了浮点变量c并赋初值
4    vec3 va=vec3(2.3,2.5,3.8);
5    vec3 vb=vec3(a,b,c);
6    vec3 vc=vec3(vb.x,va.y,14.4);
7    mat3 ma=mat3(1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,c);//用9个字面常量初始化33矩阵
8    mat3 mb=mat3(va,vb,vc);               //用3个向量初始化33矩阵
9    mat3 mc=mat3(va,vb,1.0,2.0,3.0);      //给出多个向量和字面常量以初始化33矩阵
10   mat3 md=mat3(2.0) ;                   //给出1个字面常量以初始化33矩阵
11   mat4x4 me=mat4x4(3.0);//等价于mat4x4(3.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,   
     3.0,0.0,0.0,0.0,0.0,3.0)
12   mat3x3 mf=mat3x3(me);//等价于mat3x3(3.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,3.0) 
13   vec2 vd=vec2(a,b);
14   mat4x2 mg=mat4x2(vd,vd,vd,vd);
15   mat2x3 mh=mat2x3(mg);//等价于mat2x3(6.3,11.4,0.0, 6.3,11.4,0.0)
16   mat4x4 mj=mat4x4(mf);//等价于mat4×4(3.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,   
     3.0,0.0, 0.0,0.0,0.0,1.0)
```

# 混合选择
```c
通过运算符“.”可以进行混合选择操作，在运算符“.”之后列出一个向量中需要的各个分量的名称，然后选择并重新排列这些分量。下面的代码片段说明了这个问题。

1    vec4 color= vec4(0.7,0.1,0.5,1.0); //声明一个vec4类型的向量color
2    vec3 temp=color.agb;               //将一个向量(1.0,0.1,0.5)赋值给temp
3    vec4 tempL=color.aabb;             //将一个向量(1.0,1.0,0.5,0.5)赋值给tempL
4    vec3 tempLL;                       //声明了一个三维向量tempLL
5    tempLL.grb=color.aab;              //对向量tempLL的3个分量赋值


一次混合最多只能列出4个分量的名称，且同一次出现的分量名称必须来自同一名称组。3个名称组分别为xyzw、rgba、stpq。如“color.xa”就是错误的，因为分量名称没有来自同一个组。
各分量名称在进行混合时可以改变顺序以重新排列。
以赋值表达式中的“=”为界，其左侧称为L值（要写入的表达式），右侧称为R值（所读取的表达式）。混合时，R值可以使用一个向量的各个分量任意地进行组合或重复使用，而L值不能有重复分量，但可以改变分量顺序。
```

# 注意  

```
赋值运算符中最常用的“=”在操作时，要求符号两边的操作数类型必须完全相同。这一点很特殊，与C/C++以及Java等通用编程语言不同，着色语言的赋值没有自动类型转换或提升功能。例如“float a=1;”就是错的，因为左侧的a是浮点型，右侧的1是整型。
```


# 限定符    
## in/centroid in限定符    
```
in/centroid in 限定符修饰的全局变量又称为输入变量，形成当前着色器与渲染管线前驱阶段的动态输入接口。输入变量的值是在着色器开始执行时由渲染管线的前一阶段送入。在着色器程序执行过程中，变量不可以被重新赋值。in/centroid in 限定符的使用分为如下两种情况。

1.顶点着色器的输入变量。
在顶点着色器中只能使用in限定符来修饰全局变量，不能使用centroid in 限定符和interpolation限定符。在顶点着色器中使用in限定符修饰的变量可接收渲染管线传递给顶点着色器的当前待处理的顶点的各种属性值。这些属性值各自拥有独立的副本，用于描述顶点的各项特征，如顶点坐标、法向量、颜色、纹理坐标等。

2.片元着色器的输入变量
片元着色器中可以使用in或centroid in 限定符来修饰全局变量，该变量用于接收来自顶点着色器的相关数据，最典型的是接收根据顶点着色器的顶点数据插值产生的片元数据。

在片元着色器中，in/centroid in 限定符可以修饰的类型包括有符号或无符号的整型标量、整型向量、浮点数标量、浮点数向量、矩阵变量、数组变量或结构体变量。然而，当片元着色器中in/centroid in变量的类型为有符号或无符号整型标量或整型向量时，变量必须使用flat限定符来修饰。
```

## uniform 限定符
```
uniform为一致变量限定符，一致变量指的是在由同一组顶点组成的单个3D物体中所有顶点都是相同的量。uniform变量可以用在顶点着色器或片元着色器中，用来修饰所有的基本数据类型。与in变量类似，一致变量的值也是从宿主程序(如js)传入的。
```

## out/centroid out 限定符
```
out/centroid out 限定符修饰的全局变量又称为输出变量，形成当前着色器与渲染管线后继阶段的动态输出接口。通常在当前着色器程序执行完毕时，输出变量的值才被送入后继阶段进行处理。因此，不能在着色器中声明同时起到输入和输出作用的in/out全局变量，out/centroid out 限定符的使用分为如下两种情况。

1. 顶点着色器的输出变量。
在顶点着色器中可以使用out或centroid out 限定符修饰全局变量，以向渲染管线后继阶段传递当前顶点的数据。

在顶点着色器中，out/centroid out 限定符只能用来修饰浮点型标量、浮点型向量、矩阵变量、有符号或无符号的整型标量或整型向量、数组变量及结构体变量。当顶点着色器中out/centroid out变量的类型为有符号或无符号的整型标量或整型向量时，变量也必须使用flat 限定符来修饰。

2. 片元着色器的输出变量
在片元着色器中只能使用out 限定符来修饰全局变量，而不能使用centroid out 限定符。片元着色器中的out变量一般指的是由片元着色器写入计算片元颜色值的变量，一般需要在片元着色器的最后对其进行赋值，并将其送入渲染管线的后继阶段进行处理。

在片元着色器中，out 限定符只能用来修饰浮点型标量、浮点型向量、有符号或无符号的整型量或整型向量及数组变量，不能用来修饰其他类型的变量。下面的代码片段给出了在片元着色器中正确使用out 限定符的情况。
```
## const限定符
```
用const限定符修饰的变量值是不可以变的，也就是常量，又称为编译时常量。编译时常量在声明的时候必须进行初始化，同时这些常量在着色器外部是完全不可见的。
```

## 插值限定符   
```
插值（interpolation）限定符主要用于控制顶点着色器传递到片元着色器的数据的插值方式。插值限定符包含smooth、flat两种

1. smooth
如果在顶点着色器中out变量之前含有smooth 限定符或者不含有任何限定符，则传递到后继片元着色器对应的in变量的值，是在光栅化阶段由管线根据片元所属图元各个顶点对应的顶点着色器对此out变量的赋值情况，及片元与各顶点的位置关系插值产生
2. flat
如果在顶点着色器的out变量之前含有flat 限定符，则传递到后继片元着色器中对应in变量的值不是在光栅化阶段插值产生的，一般是由图元中与最后一个顶点对应的顶点着色器对此out变量所赋的值来决定的。此时，图元中每个片元的此项值均相同。

若顶点着色器中输出变量的类型为整型标量或整型向量，则变量必须使用flat 限定符来修饰。与之对应，若片元着色器中输入变量的类型为整型标量或整型向量，变量必须使用flat 限定符来修饰。

注意
无论顶点着色器中的out全局变量被哪种插值限定符所修饰，在后继片元着色器中必须含有与之对应的由修饰符修饰的in全局变量
```

## 一致块   
```
多个一致变量的声明可以通过类似结构体形式的接口块来实现，该形式的接口块又称为一致块（uniform　block）。一致块的数据是通过缓冲对象送入渲染管线的，以一致块形式批量传送数据比单个传送效率高，其基本语法为：

[<layout 限定符>] uniform 一致块名称 {<成员变量列表>} [<实例名>]
从上述语法中可以看出，声明一致块时可能包含5个组成部分，分别是“layout 限定符”“uniform修饰符”“一致块名称”“成员变量列表”“实例名”。

uniform为修饰 一致块的关键字，声明一致块时必须使用该关键字。
应用程序是通过一致块名称来识别一致块的。一致块名称要满足着色语言的命名规定，可以包含字母、数字、下划线，其中起始字符不能为数字，可以为字母或下划线。
成员变量列表中可以包含多个变量的声明，这与普通结构体内成员变量的声明类似。
实例名是一致块的实例名称，其命名规则与一致块的相同。下面的代码片段给出了一致块在顶点着色器中的正确使用。
1    uniform Transform{           //声明一个uniform接口块
2    float radius;                //半径成员
3    mat4 modelViewMatrix;        //矩阵成员
4    uniform mat3 normalMatrix;   //矩阵成员
5    } block_Transform;


创建一致块时，可以声明实例名，也可以不声明实例名。下面分两种情况进行介绍。

未声明实例名
如果在创建一致块时未声明实例名，则一致块内的成员变量与在块外的一样。其作用域是全局的，宿主语言既可以直接通过一致块的成员变量名称访问对应变量，也可以通过“<一致块名称>.<成员变量名>”的形式访问一致块的成员变量。

声明实例名
如果在创建一致块时声明了实例名，则一致块内成员变量的作用域为从声明开始到一致块结束，宿主语言通过“<一致块名称>.<成员变量名>”访问成员变量，而着色器则需要通过“<实例名>.<成员变量名>”访问一致块的成员变量。
```

## 接口限定符有in、out、uniform这3种

## layout 限定符
```
layout 限定符是从WebGL 2.0开始出现的，主要用于设置变量的存储索引（即引用）值，声明有几种不同的形式。

可以作为接口块定义的一部分或者接口块的成员。
也可以仅修饰 uniform，以成为其他一致变量声明的参照，语法如下。
<layout 限定符> uniform
还可以修饰被接口限定符修饰的单独变量，语法如下。
<layout 限定符> <接口限定符> <变量声明>

# 上述着色器中的layout 限定符必须在存储（storage）限定符之前使用，且由layout 限定符修饰的变量或接口块的作用域必须是全局的。

1.layout 输入限定符
顶点着色器允许 layout 输入限定符修饰输入变量的声明。下面的代码片段说明了这种形式。
layout (location=0) in vec3 aPosition; // aPosition 输入变量的引用值为0
layout (location=1) in vec4 aColor;    // aColor 输入变量的引用值为1
片元着色器内不允许有layout 输入限定符

2.layout 输出限定符
在片元着色器中，layout 限定符通过location值将输出变量和指定编号的绘制缓冲绑定起来。每一个输出变量的索引（引用）值都会对应一个相应编号的绘制缓冲，而这个输出变量的值将写入相应缓冲
layout (location=0) out vec4 fragColor;    //此输出变量写入到0号绘制缓冲
layout (location=1) out vec4 colors[2];    //此输出变量写入到1号绘制缓冲
顶点着色器不允许有layout 输出限定符。如果在片元着色器中只有一个输出变量，则不需要用layout修饰符说明其对应的绘制缓冲，在这种情况下，默认值为0。如果片元着色器中有多个输出变量，则不允许重复使用相同的location值。

3.一致块layout限定符
暂时省略       
```


# 程序结构
```c
// 着色器程序一般由3部分组成，主要包括全局变量声明、自定义函数、main函数。下面的代码片段给出了一个完整的顶点着色器程序。
#version 300 es
uniform mat4 uMVPMatrix;                 //总变换矩阵
layout (location = 3) in vec3 aPosition; //顶点位置
layout (location = 2) in vec4 aColor;    //顶点颜色
out vec4 vColor;                         //传递给片元着色器的输出变量
void positionShift(){                    //根据总变换矩阵计算此次绘制顶点位置的方法
     gl_Position = uMVPMatrix * vec4(aPosition,1); 
}
void main(){                             //主函数
  positionShift();                         //根据总变换矩阵计算此次绘制的顶点位置
  vColor = aColor;                         //将接收的颜色传递给片元着色器
}

第1行声明使用的着色语言为3.0版本，每个着色器开始都必须使用该语句来声明着色语言版本。
第2～5行为全局变量的声明，根据具体情况，代码可能会有增加或减少。
第6～8行为自定义的函数，这一部分根据需要可能没有，也可能有很多不同的函数。
第7行的gl_Position是顶点着色器中的内建变量，这部分内容在下一节将进行详细介绍。
第9～12 行为主函数main，这是每个着色器里面都必须有的部分。

注意
每个着色器都必须在着色器程序的第1行通过“#version 300 es”语句声明使用3.0版的着色语言。如果没有该语句，则表示着色语言的版本是2.0。另外，与很多高级语言不同，着色器程序要求被调用的函数必须在调用之前声明，且在自己开发的着色器中自己开发的函数不可以递归调用。如上述代码中首先在第6 行声明了positionShift函数，然后在第10 行进行调用。

```
