为什么设计成单线程
  为了防止出现矛盾的命令
  因为js最初是为浏览器设计的
  如果是多线程同时对一个dom操作
  一个命令是删除，另一个是其他的命令
  那么浏览器该怎么执行
为什么需要异步
  因为js是单线程自上而下的
  如果没有异步
  当运行到某行如果需要很多时间解析执行
  那么下面的代码就会被阻塞
  则会让人觉得页面卡死，导致很差的用户体验
动态加载脚本
  let script = document.createElement('script')
  script.src = 'xx.js'
  document.head.appendChild(script)
  在把元素添加到dom且执行到这段代码之前不会发送请求。
  默认情况下，这种方式创建的s元素是以异步方式加载的相当于加了async属性，但是不是所有浏览器都支持asnc属性，所以要统一动态脚本的加载行为，可以明确将其设置未同步加载
  script.async = false
  以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响他们在资源获取队列的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们
link rel=‘preload’ href=‘xx.js’

数据类型
六种简单数据类型（原始类型）：undefined，null，boolean，number，striing，symbol
一种复杂数据类型object
严格来说函数在核心ecmascript中被认为是对象，不代表一种数据类型。但是它也有自己的特殊属性，所以有必要通过typeof操作符来进行区分函数和其他对象


number类型
let octalNumb1=070 //八进制的56
let octalNumber2=079 //无效八进制会被当成79处理
在严格模式下前导字面量0是无效的，会导致引擎报错，是应用0o当八进制前导字面量
十六进制0x123456789ABCDEF
浮点值如果小数点后没有实际设置如10.0会被当成10处理

3.125e7 //等于31250000
科学计数法也可以用于表示非常小的数值，0.000003 可以表示为3e-6

可以表示的最小数值保存在 Number.MIN_VALUE中 这个值在多数浏览器中是5e-324
最大值Number.MAX_VALUE中 这个值在多数浏览器中是1.7976931348623157e+308
如果某个计算得到的数值超过了js可以表示的范围那么这个数值会被自动转换称为特殊的infinity，-infinity
确定一个值是不是有限大可以使用isFinite()
console.log(isFinite(Number.MAX_VALUE+Number.MIN_VALUE))

NaN（not a number）
用于表示本来要返回数值的操作失败了，比如用0除任意数值在其他语言中通常会导致报错，从而终止代码执行
但在es中0，+0，-0相除都会返回NAN
0/0 // NaN
-0/+0 //NaN
如果分子是非0值，分母是有符号0或者无符号0，则会返回infinity 或者 -infinity
5/0 //Infinity
5/-0 //-Infinity
任何涉及NaN的操作始终返回NaN如NaN/10，在连续多步计算时可能是个问题。其次，NaN不等于包括NaN在内的任何值
NaN==NaN //false
所以es提供了isNaN（）函数，接收一个任意数据类型的参数，然后判断是否不是参数，任何不能转换为数值的值都会导致这个函数返回true
isNaN(NaN) //true
isNaN(10) //false
isNaN('10') //false 可以转换成数值10
isNaN('blue') //true 不可以转换为数值
isNaN(true) //false 可以转换成数值1

Number（）函数基于如下规则执行转换
布尔 true 1 false 0
数值返回本身
null 0
undefined NaN
字符串：
1. 如果字符串包含数值字符，包括数值字符前面带加，减号的情况，则转换为一个十进制数值。因此，Number('1')返回1
2. 如果字符串包含有效浮点值如'1.1'则转换为相应的浮点值（同样，忽略前面的零）
3. 如果字符串包含有效的十六进制格式如 ‘0xf’则会转换为相应的十进制数值
4. 如果是空字符串‘不包含字符’则返回0
5. 如果字符串包含除上述情况之外的其他字符返回NaN

对象，调用valueOf（）方法，并按照上述规则转换返回的值。如果是NaN则调用toString（）方法再按照转换字符串的规则转换
从不同数据类型到数值的转换有时候会比较复杂，看一看Number转换规则就知道了。
Number('hellow') //NaN
Number('') //0
Number('00011') //11
Number(true) //1

字符串的特点
es中的字符串是不可变的，一旦创建，他们的值就不能改变了。要修改莫格变量中的字符串值，必须先销毁原始的字符串
然后将包含新值的另一个字符串保存到该变量
let lang=‘java’
lang+=’script‘
整个过程首先会分配一个足够燃10个字符的空间，然后填充上jajva和script 最后销毁这两个字符串。

转换为字符串
有两种方法，首先是使用几乎所有值都有的toString方法，这个方法唯一的用途就是返回当前值的字符串等价物
let age = 11
age.toString()//字符串'11'
let f = true
f.toString //字符串'true'
null,undefined没有toString方法
多数情况下，不接受任何参数，不过在对数值调用这个方法时可以接收一个底数参数，默认情况下，
toString返回数值的十进制字符串表示
let n = 10
n.toString() //'10'
n.toString(2) // '1010'
n.toString(16) //'a'

如果不确定一个值是不是null或者undefined，可以使用string函数，它始终会返回表示相应类型的字符串
按照如下规则
如果值有toString方法则调用该方法，并返回结果
如果知识null返回’null‘
如果是undefined返回’undefined‘

标签函数，本身是一个常规函数，通过前缀到模板字面量来应用自定义行为
接收到的参数一次是原始字符串数组和对某个表达式求值的结果，
这个函数的返回值是对模板字面量求值得到的字符串

按位操作符
按位非~，正数相当于变负值减1
let a = 2
~a // -3
按位异或，两个操作数的位相同取0，不同取1
左移<< 后面填充0
右移(有符号)>>，位整体右移n个单位，前面填充0还是1看符号位
右移(无符号)>>>,整体右移n个单位，前面填充0

布尔操作符
逻辑非 ！
连续使用两个!! 相当于调用了Boolean（）函数返回变量真正对应的布尔值
！！'bb' // true

逻辑与(短路操作符，如果第一个操作数绝定了结果，就不会对第二个求值) &&
如果第一个操作数是对象，返回第二个操作数
如果第二个操作数是对象，只有第一个是true才会返回该对象
两个都是对象，返回第二个
有一个是null，返回null
有一个是NaN，返回NaN
有一个是undefined，返回undefined

逻辑或(短路操作符，不过第一个求值位true，第二个操作数就不会再被求值了) ||
第一个是对象，返回第一个
第一个是false，返回第二个
两个都是对象，返回第二个
两个都是null，返回null
两个都是NaN，返回NaN
两个都是undefined，返回undefined

关系操作符
两个单词字符串比较，大写字母的编码都小于小写字母的编码因此会发生如下情况：
let res = 'Brick' < 'alphabet' //true
这里。字符‘Brick’被认为小于字符串‘alphabet’，要得到确实按字母顺序比较的结果，就必须把两者都
转换位相同的大小写形式然后再比较
let res = "Brick".toLowerCase()<"aplhabet".toLowerCase() //false
还有一个奇怪的现象是比较两个数值字符串时
let res = '23' < '3' //true
因为'2'编码50，‘3’编码是51
let res = '23' < 3 //false
这次会将字符串‘23’转换位23，然后再跟3比较，结果就会对了，只要是数值和字符串比较，字符串就会被先转换位数值
let res = "a" < 3 //因为‘a'会被转换位NaN 所以结果是false

相等操作符
es中的相等和不相等操作符，原本在比较之前会执行类型转换
最后，es提供了两组操作符，分别是等于和不等于，在比较之前执行转换；全等和不全等，比较之前不执行转换
等于和不等于
es中用==表示，如果操作数相等返回true。这两个操作数都会先进行类型转换（强制类型转换）再确定操作数是否相等
遵循如下规则
如果任一操作数是布尔值，则将其转换位数值再比较是否相等。fase转换为0
如果是字符串，另一个是数值，则尝试将字符串转换为数值，再比较是否相等
如果是对象，另一个不是，则调用对象的valueOf()方法取得其原始值，再根据前面的规则进行比较：
	比较时，这两个操作符遵循如下规则
	null和undefined相等
	null和undefined不能转换为其他类型的值再进行比较
	如果任一操作数为nan，相等操作符返回false， 不相等返回true
如果两个都是对象，比较是不是同一个对象，如果都指向同一个对象，则相等操作符返回true


for-in语句
是一种严格的迭代语句，用于枚举对象中的非符号键属性
for(t in obj)
例子
for(const t in window){
	document.write(t)
}
为了确保这个局部变量不被修改，推荐使用const
es中对象的属性是无序的，因此，for-in语句不能保证返回对象属性的顺序。
换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因为浏览器而不同
如果for-in循环要迭代的变量是nll或者undefined，则不执行循环体


for-of严格迭代语句，用于遍历可迭代对象的元素
for(const e of [2,3,4,5]){
	document.write(e)
}
for-of循环会按照可迭代对象的next()方法产生值的顺序迭代元素。
如果尝试迭代的变量不支持迭代，则for-of语句会抛出错误。

标签语句,语法：
label: statement
例子：
start: for(let i=0;i<count;i++){
	console.log(i)
}
start是一个标签，可以涛哥break或者continue语句引用

通过标签语句+break跳出多层循环
let n=0
outermost:
for(let i=0;i<10;i++){
	for(let j=0;j<10;j++){
		if(i==5&&j==5){
			// 当这个条件达成时，从outermost开始继续往下执行，但是已经break，所以跳过循环语句
			break outermost
		}
		n++
	}
}
console.log(n)//55
//如果是continue outermost 则是95，因为只是跳过了i==5 j>5 <10这5个数，继续从外层执行循环

内存泄漏
1.意外声明全局变量
function s(){
	name='123'
}
此时，解释器会把name当作window的属性来创建

2.定时器
let name='jake'
setInterval(()=>{
	console.log(name)
}, 1000)
这里是定时器回调通过闭包引用外部变量
只要定时器一直运行，回调函数中的引用name就会一直占用内存

3.闭包
let outer = function(){
	let name = 'jake'
	return function(){
		return name
	}
}
调用outer()会导致分配给name的内存泄漏，只要返回的函数存在就不能清理name，因为闭包一直在引用着它

4.静态分配与对象池



RegExp
通过RegExp类型支持正则表达式，字面量//
let expression = /pattern/flags
这个正则表达式的pattern(模式)可以是任何简单或者复杂的正则表达式；
每个正则表达式可以带0个或者多个flags（标记）用于控制正则表达式的行为，下面给出了表示匹配模式的标记。
g: 全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束
i: 不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写
m: 多行模式，表示查找到一行文本末尾时会继续查找
y: 粘附模式，表示只查找从lastIndex开始及之后的字符串
u: Unicode模式，启用Unicode匹配
s: dotAll模式，表示元字符.匹配任何字符(包括\n或者\r)
例子
//匹配字符串中的所有 "at"
let pattern1 = /at/g
//匹配第一个‘bat’或者‘cat’，忽略大小写
let pattern2 = /[bc]at/i
//匹配所有以‘at’结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi

与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：
([{\^$|}])?*+.

//匹配第一个‘[bc]at’，忽略大小写
let pattern2 = /\[bc\]at/i
//匹配所有'.at',忽略大小写
let pattern4 = /\.at/gi

可以使用构造函数创建
let p = new RegExp('[bc]at','i')
注意RegExp的模式参数是字符串，所以某些情况下需要二次转义
比如
字面量模式 /\[bc\]at/  对应的字符串 "\\[bc\\]at"
/\w\\hello\\123/   "\\w\\\\hello\\\\123"

RegExp 也可以基于已有的正则表达式实例，并可选择性地修改他们的标记
const re1 = /cat/g
console.log(re1) //'/cat/g'

const re2 = new RexExp(re1)
console.log(re2) //'/cat/g'

const re3 = new RegExp(re1,'i')
console.log(re3) //'/cat/i'

RegExp实例方法
主要是exec(),主要用于配合捕获组使用。这个方法只接受一个参数，即要引用模式的字符串。
如果找到了匹配项，则返回包含第一个匹配信息的数组，如果没有找到匹配项则返回null。
虽然返回数组是Array的实例，但是包含两个额外的属性，index和input。
index是字符串中匹配模式的起始位置，input是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，
其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。
let txt = 'mom and dad and baby';
let pattern = /mom( and dad( and baby)?)?/gi;
let matches = pattern.exec(txt)
console.log(matches.index); //0
console.log(matches.input); // 'mom and dad and baby'
console.log(matches[0]); // 'mom and dad and baby'
console.log(matches[1]); // ' and dad and baby'
这个例子中，模式包含两个捕获组，最内部的匹配项‘and baby’以及外部的匹配项‘and dad’或者‘and dad and baby’。
调用exec()后找到了一个匹配项。因为整个字符串匹配模式，所以matchs数组的index属性就是0.
数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。
如果模式设置了全局标记，则每次调用exec()方法会返回一个匹配的信息。如果没有设置全局标记g，则无论对同一个字符串调用多少次exec()，也只会返回第一个匹配的信息。
let txt = 'cat, bat, sat, fat';
let pattern = /.at/;
let matches = pattern.exec(txt)
console.log(matches.index); //0
console.log(matches[0]); // cat
console.log(matches.lastIndex); // 0

matches = pattern.exec(txt)
console.log(matches.index); //0
console.log(matches[0]); // cat
console.log(matches.lastIndex); // 0
上面没有设置全局标记，因此调用exec()只返回第一个匹配项('cat').lastIndex在非全局模式下始终不变。
如果设置了g标记，则每次调用exec()都会在字符串中向下搜索下一个匹配项
let txt = "cat, bat, sat, fat";
let pattern = /.at/g;
let matches = pattern.exec(txt);
console.log(matches.index); //0
console.log(matches[0]); // cat
console.log(matches.lastIndex); // 3

matches = pattern.exec(txt);
console.log(matches.index); //5
console.log(matches[0]); // bat
console.log(matches.lastIndex); // 8

matches = pattern.exec(txt);
console.log(matches.index); //10
console.log(matches[0]); // sat
console.log(matches.lastIndex); // 13
在全局模式匹配下，每次调用exec()都会更新lastIndex值，以反映上次匹配的最后一个字符的索引。
如果模式设置了黏附标记y，则每次调用exec()就只会在lastIndex的位置上寻找匹配项。黏附标记覆盖全局标记。
let txt = "cat, bat, sat, fat";
let pattern = /.at/y;
let matches = pattern.exec(txt);
console.log(matches.index); //0
console.log(matches[0]); // cat
console.log(matches.lastIndex); // 3

//以索引3对应的字符开头找不到匹配项，因此exec()返回null
// exec()没找到匹配项，预设将lastIndex设置为0
matches = pattern.exec(txt);
console.log(matches); //null
console.log(matches.lastIndex); // 0

//向前配置lastIndex可以让黏附模式通过exec()找到下一个匹配项
pattern.lastIndex = 5;
matches = pattern.exec(txt);
console.log(matches.index); //5
console.log(matches[0]); //bat
console.log(matches.lastIndex); // 8


RegExp 构造函数本身也有几个属性，这些属性使用于作用域中的所有正则表达式，而且会根据最后
执行的正则表达式操作而变化。
这些属性有一个特点，就是可以通过两种不同的方式访问他们。
全名  简写  说明
input $_   最后搜索出来的字符串(非标准特性)
lastMatch $& 最后匹配的文本
lastParen $+ 最后匹配的捕获组(非标准特性)
leftContext $` input字符串中出现在lastMatch前面的文本
rightContext $' input字符串中出现在lastMatch后面的文本
通过这些属性可以提出来了与exec()和test()执行的操作相关的信息
例子
let txt = 'this has been a short summer';
let pattern = /(.)hort/g;
if(pattern.test(txt)){
	console.log(RegExp.input); //this has been a short summer
	console.log(RegExp.leftContext); //this has been a 
	console.log(RegExp.rihtContext); //summer
	console.log(RegExp.lastMatch); //short
	console.log(RegExp.lastParen); //s
	//简写
	console.log(RegExp.$_); //this has been a short summer
	console.log(RegExp.["$`"]); //this has been a 
	console.log(RegExp.["$'"]); //summer
	console.log(RegExp.["$&"]); //short
	console.log(RegExp.["$+"]); //s
}


原始值包装类型
例子
let s1  = 'xx'
let s2 = s1.substring(0)
s1是一个包含字符串的变量，是个原始值；原始值本身不是对象，不应该有方法，这是因为后台进行了处理。
在以读模式访问字符串值的任何时候，后台都会执行以下三步
1. 创建一个String类型的实例
2. 调用实例上的特定方法
3. 销毁实例
以上可以想象成执行了如下3行es代码
let s1 = new String('xx');
let s2 = s1.substring(0);
s1 = null

上面的例子可以想象成
let s1  = 'xx';
let s2 = function(s1){
	let s1 = new String('xx');
	let s2 = s1.substring(0);
	s1 = null;
	return s2;
}()
例子2
let s1 = 'some txt';
s1.color = 'red';
console.log(s1.color); //undefined
这里的第二行代码尝试给字符串s1添加color属性。可是第三行访问color属性时，却不见了。原因就是
第二行代码运行时会临时创建一个String对象，而第三行执行时这个对象已经被销毁了。
实际上，第三行代码在这里创建了自己的String对象，但这个对象没有color属性。

另外，Object构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例，比如：
let obj = new object('some txt');
console.log(obj instanceof String); //true

如果传给Object的是字符串，则会创建一个String 的实例.如果是数值则会创建Number实例，，，
注意使用new调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：
let value = '25';
let number = Number(value); //转型函数
console.log(typeof number); //'number'
let obj = new Number(value); //构造函数
console.log(typeof obj); //'object'

Number类型提供了几个用于将数值格式化为字符串的方法

toFixed()方法返回包含指定小数点位数的数值字符串，如:
let num = 10;
console.log(num.toFixed(2)); //'10.00'
如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：
let num = 10.005;
console.log(num.toFixed(2)); //"10.01"

toExponential(),返回以科学计数法表示的数值字符串. 与toFixed()一样，他也接收一个参数。
表示结果中小数的位数。
let num = 10；
console.log(num.toExponential(1));  //"1.0e+1"

一般来说，这么校的数不用表示为科学计数法，如果想得到数值最适合的形式，可以使用toPrecision().
这个会根据情况返回最合理的输出结果，可能是固定长度，接收一个参数，表示结果中数字的总位数(不含指数)。例子：
let num = 99;
console.log(num.toPrecision(1)); // "1e+2"
console.log(num.toPrecision(2)); // "99"
console.log(num.toPrecision(3)); // "99.0"

isInteger()方法与安全整数
es6新增了Number.isInteger()方法，用于判断一个数值是否保存为整数。
有时候，小数位的0可能会让人误以为是一个浮点值：
consoel.loog(Number.isInteger(1)); //true
console.log(Number.isInteger(1.00)); //true
console.log(Number.isInteger(1.01)); //false



js字符
js字符串由16位码元(code unit)组成。对多数字符来说，每16位码元对应一个字符。换句话说，字符串的length属性
表示字符串包含多少16位码元：
let message = 'abcde';
message.length //5

charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，
这个方法查找指定索引位置的16位码元，并返回该码元对应的字符:
let message = 'abcde';
message.charAt(2) //'c'

使用charCodeAt()方法可以查看指定码元的字符编码。 这个方法返回指定索引位置的码元值，索引以整数指定
比如:
let message = 'abcde';
message.charCodeAt(2); // 99

字符串操作方法
concat(),用于将一个或者多个字符串拼接成一个新字符串。例子
let stringValue="hello ";
let result = stringValue.concat("world");
console.log(result); //"hello word"
console.log(stringValue); //"hello"

es提供了3个从字符串中提取字符串的方法
slice()
substr()
substring()
这三个方法都是返回调用他们的字符串的一个字符串，而且都接收一个或者两个参数，
第一个表示子字符串开始的位置，第二个参数表示子字符串结束的位置，
对于slice和substring而言，第二个参数是提取结束的位置(即该位置之前的字符会被提取出来).
对substr而已，第二个参数表示返回的子字符串数量.
任何情况下，省略第二个参数都意味着提取到字符串末尾。
与concat一样，他们不会修改调用他们的字符串。而只会返回提取到的原始新字符串值

当某个参数是负值时，这三个方法的行为又有不同。
比如，slice方法将所有负值参数都当成字符串长度加上负参数值。
substr方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0.
substring方法会将所有负参数值都转换为0.

例子：
let stringValue = "hello world";
stringValue.slice(-3); //'rld' 相当于stringValue.slice(8) 8=11-3
stringValue.substring(-3); //'hello world'相当于stringValue.substring(0)
stringValue.substr(-3); //'rld' 相当于stringValue.substr(8)

stringValue.slice(3,-4); //"lo w" 相当于stringValue.slice(3,7)
stringValue.substring(3, -4); // "hel" 相当于stringValue.substring(3,0)而又等价于相当于stringValue.substr(0,3),因为这个方法会将小参数作为起点
stringValue.substr(3,-3); //'' 相当于stringValue.substr(3,0)

字符串位置方法
有两个方法用于在字符串中定位子字符串: indexOf()和lastIndexOf()。
这两个方法从字符串中搜索传入的字符串，并返回位置(没有找到，返回-1).
两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而lastIndexOf()从字符串末尾开始查找
例子:
let str = "hello world";
str.indexOf("o"); //4
str.lastindexOf("o"); //7
这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。
这意味着，indexOf会从这个参数指定的位置开始向末尾搜索，忽略该位置之前的字符；
lastIndexOf则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符串
例子
let str = "hello world";
str.indexOf("o",6); //7
str.lastindexOf("o",6); //4

遍历一个字符串中所有的某个字符
例如：
let stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
let positions  = new Array();
let pos = stringValue.indexOf('e');
while(pos>-1){
	positions.push(pos);
	pos = stringValue.indexOf('e',pos+1);
}

字符串包含的方法
es6 增加了3个用于判断字符串中是否包含另一个字符串的方法： 
startsWith()
endsWith()
includes()
这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。
区别在于第一个检查开始于索引0的匹配项，
第二个检查开始于索引(string.length-substring.length)的匹配项
最后一个检查整个字符串
例子：
let message = "foobarbaz";
message.startsWith('foo'); //true
message.endsWith('baz'); //true  开始于9-3=6
message.includes('bar'); //true

startsWith和includes接收可选的第二个参数，表示开始搜索的位置，则意味着会从指定位置向着字符串末尾搜索，
忽略该位置之前的所有字符
endsWith()接收第二个参数，表示应该当作字符串末尾的位置，如果不提供整个参数，那么默认字符串长度
如果提供，那么好像字符串只有那么多字符一样

trim方法
es在所有字符串上都提供了trim方法，这个方法会创建字符串的一个副本，输出前后所有空格，再返回结果。
这个方法返回的是字符串的副本，不会影响原始的字符串

repeat方法
接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果
let str = 'n '
console.log(str.repeat(2)+'hh'); // 'n n hh'

padStart和padEnd
会复制字符串，如果小于指定长度，则再相应的一边填充字符，直至满足长度条件。
第一个参数是长度，第二个长度是可选的填充字符串，默认为空格
例子
let str = 'foo'
str.padStart(6) // '   foo'

字符串迭代与解构
字符串的原型上暴露了一个@@iterator方法，表示可以迭代字符串的每个字符，可以像下面这样手动使用迭代器：
let message="abc";
let stringIterator = message[Symbol.iterator]();
stringIterator.next() // {value:'a',done:false}
stringIterator.next() // {value:'b',done:false}

字符串大小写转换
toLowerCase，toLocaleLowerCase，toUpperCase，toLocaleUpperCase
Locale的方法旨在要使用地区特定的方法才能实现的正确转换，
如果不知道代码涉及什么语言，最好使用带有locale的转换方法

字符串模式匹配方法
match，本质上跟RegExp对象的exec方法相同。接收一个参数，可以是一个正则表达式字符串也可以是regexp对象
例子
let txt = “cat, bat, sat, fat";
let pattern = /.at/;
等价于pattern.exec(txt)
let matches = txt.match(pattern);
matches.index; // 0
matches[0]; //'cat'
pattern.lastIndex; //0
match方法返回的数组与RegExp对象的exec方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串
其余元素则是与表达式中的捕获组匹配的字符串。

search方法唯一的参数与match方法一样，正则表达式字符串或regExp对象，这个方法返回模式第一个匹配的位置索引，
如果没找到则返回-1。search始终从字符串开头向后匹配模式。
例子
let txt = "cat, bat, sat, fat";
let pos = txt.search(/at/);
pos //1
search(/at/)返回1，即’at‘的第一个字符在字符串中的位置

为了简化子字符串替换操作，es提供了replace方法，接收两个参数
第一个可以是RegExp对象或者一个字符串，第二个可以是一个字符串或者一个函数。
如果第一个参数是字符串，那么只会替换第一个子字符串。
想要替换所有子字符串，第一个参数必须为正则表达式并且带有全局标记
例子
let txt = "cat, bat, sat, fat";
let res = txt.replace('at','cc')
res; // 'ccc, bat, sat, fat'
res = txt.replace(/at/g,'cc');
res; // 'ccc, bcc, scc, fcc'

localeCompare()方法
这个方法比较两个字符串，返回如下3个值中的一个
如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值(通常是-1，具体还要看与实际值相关的实现)
如果字符串与字符串参数相等，则返回0.
如果按照字母表顺序，字符串应该排在字符串参数后面，则返回正值（通常是1
例子
let str = ’yellow‘
str.localeCompare('brick'); //1 y在b后面
str.localeCompare('yellow'); //0
str.localeCompare('zoo');  //-1 y在z前面


window对象，虽然ecma没有规定直接访问global对象的方式，但浏览器将window对象实现为Global对象的代理。
因此，所有全局作用域中声明的变量和函数都变成了window的属性。

Math对象
这个对象上面提供的计算要比直接在js实现的快得多，因为math对象上的计算使用了js引擎中更高效的实现和处理器指令。
但是使用math计算的问题是精度会因为浏览器，操作系统，指令集和硬件而异。

Math对象属性
Math.E 自然对数的基数e的值
Math.LN10 10为底的自然对数
Math.LN2
Math.LOG2E 以2为底e的对数
Math.PI Π的值
Math.SQRT1_2 1/2的平方根
Math.SQRT2 2的平方根

min，max函数
可以使用Math.max(...Array)的形式取得数组的最大值

舍入方法
Math.ceil()始终向上舍入为最接近的整数
Math.floor()始终向下舍入为最接近的整数
Math.round()执行四舍五入
Math.fround()返回数值最接近的单精度（32位）浮点值表示

Math.random()返回一个0~1范围内的随机数，其中包含0但是不包含1
想从1-10随机选择一个数， Math.floor(Math.random()*10+1)
2-10则要Math.floor(Math.random()*9+2)，可选总数是9个(0-8)，最小可能值是2
所以用函数计算可选总数和最小可能值更方便
例如
lowerValue；起点值 上面的2
upperValue：终点值 上面的10
function selectFrom(lowerValue,upperValue){
	let choices = upperValue - lowerValue + 1;
	return Math.floor(Math.random()*choices + lowerValue)
}
 
如果是为了加密而需要生成随机数(传给生成器的输入需要较高的不确定性)
建议使用Window.crypto.getRandomValues()

Math.trunc(x) 返回x的整数部分，删除所有小数

Array构造函数有两个es6新增的用于创建数组的静态方法，from（）和of（），前者用于将类数组结构转换为数组实例
而of（）用于将一组参数转换为数组实例
Array.from()第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构。
这种方式可用于很多场合：
// 字符串会被拆分为单字符数组
Array.from('matt'); //['m','a','t','t']
//可以使用from将集合和映射转换为一个新数组
const m = new Map().set(1,2).set(3,4);
constt s= new Set().add(1).add(2).add(3).add(4);
Array.from(m); [[1,2],[3,4]]
Array.from(s); [1,2,3,4]
Array.from()对现有数组执行浅复制
const a1 = [1,2,3,4];
const a2  = Array.from(a1);
console.log(a1); [1,2,3,4]
alert(a1===a2) false

Array.from()还接受第二个可选的映射函数参数，这个函数可以直接增强新数组的值，而无须想调用Array.from().map()那样先
创建一个之间数组。还可以接受第三个可选参数，用于指定映射的函数中的this的值，但是这个重写的this在箭头函数中不适用
const a1 = [1,2,3,4];
const a2 = Array.from(a1, x=>x**2);
const a3 = Array.from(a1, function(x){return x**this.exponent},{exponent: 2});
a2,a3  // [1,4,9,16]
Array.of()可以把一组参数转换为数组

可以使用length属性方便地向数组末尾添加元素
a[a.length] = 'xx'


Array.isArray()确定一个值是否为数组

迭代器方法
在es6中，Array的原型上暴露了3个用于检索数组内容的方法，keys（），values（）和entries（）。
keys（）返回数组索引的迭代器，values（）返回数组元素的迭代器，而entries（）返回索引/值对的迭代器

const a = ['foo','bar','baz','qux']

//因为这些方法都返回迭代器，所以可以将他们的内容通过Array.from直接转换为数组实例
const aKeys = Array.from(a.keys()); [0,1,2,3]
const aValues = Array.from(a.values()); ['foo','bar','baz','qux']
const aEntries = Array.from(a.entries()); [[0,'foo'],[1,'bar'],[2,'baz'],[3,'qux']]

使用解构可以非常容易地在循环中拆分键值对
for( const [idx,ele] of a.entries){
	console.log(idx,ele)
}


复制和填充方法
es6新增两个方法： 批量复制方法copyWithin(),以及填充数组方法fill().这两个方法的函数签名类似，都需要指定既有数组实例上的
一个范围，包含开始索引，不包含结束索引，使用这个方法不会改变数组的大小。
使用fill()方法可以向一个已有的数组中插入全部或部分相同的值，开始索引用于指定开始填充的位置，他是可选的。
如果不提供结束索引，则一直填充到数组末尾

排序方法
sort
reverse将数组元素反向排列
sort会在每一项上调用String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，
也会先把数组转换为字符串再比较，排序，比如
let v= [0,1,5,10,15]
v.sort() 0,1,10,15,5
字符串10在5前面所以10还是会拍到5前面。
这是很不合适的，所以sort方法可以接受一个比较函数，用于判断那个值应该排在前面
比较函数接受两个参数，如果第一个参数应该排在第二个参数前面，就返回负值，交换两个位置，降序
如果两个参数相等就返回0
如果第一个参数一个排在第二个参数后面，就返回正值，交换两个位置， 升序。
sort((a,b)=>a-b) a-b 升序， b-a降序

操作方法
concat()可以在现有数组全部元素基础上插件一个新数组，它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，
最后返回这个新构建的数组
let c1 = ['red','green','blue'];
let c2 = c1.concat('yellow',['black','brown'])  ['red','green','blue','yellow','black','brown']

slice用于创建一个包含原有数组中一个或者多个元素的新数组，slice方法可以接受一个或者两个参数: 返回元素的开始索引和结束索引
如果只有一个参数，slice会返回该索引到数组末尾的所有元素，其中不包含结束索引对应的元素。这个操作不影响原始数组

splice，主要目的是在数组中间插入元素，但有3中不同的方式使用这个方法

ArrayBuffer
Float32Array实际上是一种‘视图’，可以允许js运行时访问一块名为ArayBuffer的预分配内存。ArrayBuffer是所有定型数组及视图
引用的基本单位
ArrayBuffer（）是一个普通的js构造函数，可用于在内存中分配特点数量的字节空间
cosnt buf = new ArrayBuffer(16) 在内存中分配16字节
buf.byteLength 16
ArrayBuffer一经创建就不能在调整大小，不过可以slice复制器全部或者部分到一个新实例中
const buf1 = new ArrayBuffer(16);
const buf2 = buf1.slice(4,12);
buf2.byteLength 8



生成器
拥有在一个函数块内暂停和回复代码执行的能力。
这种新能力具有深远的影响。比如，使用生成器可以自定义迭代器和实现协程。

生成器的形式是一个函数，函数名称前面加一个星号*表示它是一个生成器，只要是可以定义函数的地方，就可以定义生成器
生成器函数声明
function* generatorFn(){}
生成器函数表达式
let generatorFn = function* (){}
作为对象字面量方法的生成器函数
let foo={
	* generatorFn(){}
}
作为类实例方法的生成器函数
class Foo{
	* generatorFn(){}
}
作为类静态方法的生成器函数
class Bar{
	static * generatorFn(){}
}

注意：箭头函数不能用来定义生成器函数
标识生成器函数的星号不受两测空格的影响



属性类型
ecma-262 使用一些内部特性来描述属性的特征。这些特性是由为js实现引擎的规范定义的，因此，开发者不能在js中直接访问这些特性。
为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]

属性分为两种：数据属性和访问器属性
数据属性
数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置，数据属性有4个特性描述他们的行为
[[Configurable]]: 表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，
以及是否可以把它改为访问器属性。默认情况下所有直接定义在对象上的属性的这个特性都是true
[[Enumerable]]: 表示属性是否可以通过for-in循环返回，默认情况下，所有直接定义在对象上的属性的这个特性都是true
[[Writable]]:表示属性的值是否可以被修改。默认情况下。。。true
[[Value]]: 包含属性实际的值。这个特性默认值是undefined

要修改属性的默认特性，就必须使用Object.defineProperty()方法，这个方法接收三个参数：要给其添加属性的对象，
属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable，enumerable，writable和value
跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或者多个值，比如：
let person = {}
Object.defineProperty(person,'name',{
	writable: false,
	value: 'Nicholas'
});
person.name;  //Nicholas
person.name = 'xx'
person.name; //Nicholas

在调用这个方法时，这四个的值如果不指定，则都默认为false

访问器属性
访问器属性不包含数据值，相反，他们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必须的。
在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值，在写入访问器属性时，会调用设置函数并传入新值
这个函数必须决定对数据做出什么修改。访问器属性有四个特性描述他们的行为。
[[Configurable]]: 表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。
默认情况下，所有直接定义在对象上的属性的这个特性都是true。
[[Enumerable]]: 表示属性是否可以通过for-in循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是true。
[[Get]]: 获取函数，在读取属性时调用。默认值为undefined。
[[Set]]: 设置函数，在写入属性时调用。默认值为undefined。
访问器属性是不能直接定义的，必须使用Object.defineProperty()

定义一个对象，包含伪私有成员year_和公共成员edition
let book={
	year_: 2010,
	edition: 1
}
Object.defineProperty(book,'year',{
	get(){
		return this.year_;
	},
	set(newValue){
		if(newValue>2010){
			this.year_=newValue;
			this.editon+=newValue-2010
		}
	}
})

定义多个属性
es提供Object.defineProperties()方法。这个方法可以通过多个描述符一次性定义多个属性。接受两个参数：
要为之添加或者修改属性的对象和另一个描述符对象，其属性与要添加或者修改的属性一一对应。比如：
let book = {};
Object.defineProperties(book,{
	year_:{
		value: 2010
	},
	edition: {
		value: 1
	},
	year:{
		get(){
			return this.year_;
		},
		set(newValue){
			if(newValue > 2010){
				this.year_ = newValue;
				this.edition += newValue-2010;
			}
		}
	}
})


es6专门为合并对象提供Object.assign()方法，这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中
可枚举和自有属性复制到目标对象，以字符串和符号为键的属性会被复制。对每个符号条件的属性，这个方法会使用源对象上的[[Get]]
取到属性的值，然后使用目标对象上的[[Set]]设置属性的值
let dest, src, result;
//简单复制
dest={};
src={id:'src'};
result = Object.assign(dest, src)
//Object.assign修改目标对象
//也会返回修改后的目标对象
dest === result //true
dest!==src //true
result //{id:src}
dest  //{id:src}


//多个源对象
dest = {}
result = Object.assign(dest, {a:'foo'},{b:'bar'});
result //{a:foo,b:bar}

//获取函数与设置函数
dest = {
	set a(val){
		console.log(`Invoked dest setter with param ${val}`);
	}
};
src = {
	get a(){
		console.log('Invoked src getter');
		return 'foo'
	}
};
Object.assign(dest,src);
//调用src的获取方法
//调用dest的设置方法并传入参数‘foo’
//因为这里的设置函数不执行赋值操作
//所以实际上并没有把值转移过来
console.log(dest); //{set a(val){...}}

Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值.
此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。
换句话说，不能在两个对象间转移获取函数和设置函数。
let dest,src,result;
// 覆盖属性
dest = {id:'dest'};
result = Object.assign(dest, {id:'src1',a:'foo'},{id:'src2',b:'bar'});
//Object.assign会覆盖重复的属性
result //{id:src2,a:foo,b:bar}
//可以通过目标对象上设置函数观察到覆盖的过程
dest={
	set id(x){
		console.log(x)
	}
}
Object.assign(dest,{id:'first'},{id:'second'},{id:'third'});
//first
//second
//third

对象标识及相等判定
在es6之前，有些特殊情况即使是===操作符也无能为力
//这些是符合预期的情况
true === 1 //false
{} === {} //false
'2' === 2 //false
//这些在不同js引擎中表现不同，但仍然被认为相等
+0===-0 //true
+0===0 //true
-0===0 //true
为改善这类情况，es6新增Object.is()这个方法与===很像，但是同时也考虑到了上述边界情形
这个方法必须接受两个参数：
Object.is(true,1) //false
Object.is({},{}) //false
Object.is('2',2) //false

Object.is(-0,+0) //false
Object.is(+0,0) //true
Object.is(-0,0) //false

要检查超过两个值，递归利用相等性传递即可：
function ccc(x,...rest){
	return Object.is(x,rest[0])&&(rest.length<2||c(...rest))
}
console.log(ccc(0,0,0))
console.log(ccc(0,0,1))
// rest.length<2 最后一组的比较，不加最后会用x和undefied比较，基本都是false
/**
 *  0 [ 0, 0 ]
	0 [ 0 ]
	true
	0 [ 0, 1 ]
	0 [ 1 ]
	false
 */ 

可计算属性
在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性，换句话说，
不能在对象字面量中直接动态命名属性。比如：
const nameKey = ‘name’；
const ageKey = ‘age’；
const jobKey = ‘job’；

let person = {}；
person[nameKey] = 'Matt';
person[ageKey] = 27;
person[jobKey] = 'soft'
person //{name:'Matt',age:27,job:'soft'}

有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为js表达式而不是字符串来求值
let person = {
	[nameKey]: 'Matt',
	[ageKey]: 27,
	[jobKey]: 'soft'
}
person //{name:'Matt',age:27,job:'soft'}

因为被当作js表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时在求值
let uniqueToken = 0;
function getUniqueKey(key){
	return `${key}_${uniqueToken++}`;
}
let person = {
	[getUniqueKey(nameKey)]: 'Matt',
	[getUniqueKey(ageKey)]: 27,
	[getUniqueKey(jobKey)]: 'soft'
}
person //{name_0:'Matt',age_1:27,job_2:'soft'}

简写方法名
在给对象定义方法时，通常都要写一个方法名，冒号，然后在引用一个匿名函数表达式
let person={
	sF: function(name){
		return name
	}
}
新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名，相应的，也可以明显缩短方法声明。
一下代码和之前的代码在行为上是等价的
let person = {
	sF(name){
		return name
	}
}

简写方法名对获取函数和设置函数也是适用的
let person = {
	name_: '',
	get name(){
		return this.name_;
	},
	set name(name){
		this.name_=name
	},
	sf(){
		return this.name_
	}
}
person.name = 'x'
console.log(person.sf()) //x

简写方法名可与计算属性建相互兼容
const k = ‘say’
let person = {
	[k](name){
		return name
	}
}
person.say('xx')//xx


对象解构
es6新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或者多个赋值操作
简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值

//不使用对象解构
let person = {
	name: 'm',
	age: 20
};
let personName = person.name,
	personAge = person.age
//使用对象解构
let {name:personName,age:personAge} = person
personName //m
personAge  // 20

解构赋值不一定与对象的属性匹配，赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是undefined
let {name, job} = person
name //'m'
job //undefined

也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况
let {name, job='sof'} = person
name //'m'
job //sof
解构在内部使用函数ToObject()不能在运行时环境中直接访问 把源数据结构转换为对象。这意味着在对象解构的上下文中，
原始值会被当成对象。这也意味这（根据ToObject()的定义)
null和undefined不能被解构，否则会抛出错误
let {length} = 'foobar';
length //6
let {constructor: c} = 4
c===Number; //true

解构不要求必须在解构表达式中声明。不过如果是事先声明的变量赋值，则赋值表达式必须包含在一对括号中
let personName，personAge；
let person = {
	name: 'Matt',
	age: 27
}

({name: personName,age:personAge}=person)
personName,personAge //Matt,27

嵌套解构
解构对于引用嵌套的属性或赋值目标没有限制，为此，可以通过解构来复制对象属性
let person = {
	name: 'Matt',
	age: 20,
	job: {
		title: 'sof'
	}
}
let personCopy={}
({
	name: personCopy.name,
	age:personCopy.age,
	job: personCopy.job
}=person)

因为一个对象的引用被赋值给personCopy，所以修改
person.job对象的属性也会影响personCopy
person.job.title='H'
person //{name: 'Matt', age: 20, job: {title: 'sof'}}
personCopy //{name: 'Matt', age: 20, job: {title: 'sof'}}

解构赋值可以使用嵌套结构，以匹配嵌套的属性
let {job:{title}} = person
title //sof

在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：
let person = {
	job: {
		title: 'sof'
	}
}
let personCopy = {}
// foo在源对象上是undefined
({
	foo:{
		bar: personCopy.bar
	}
})
报错 Cannot destructure property 'bar' of 'undefined' or 'null'.
//job在目标对象上是undefined
({
	job: {
		title: personCopy.job.title
	}
})
报错TypeError: Cannot set property 'title' of undefined

部分解构
涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错
则，整个解构赋值只会完成一部分
let person={
	name:'m',
	age: 27
};
let personName,personBar,personAge;
try{
	//person.foo  是 undefined，因此会抛出错误
	({name: personName, foo:{bar:personBar},age:personAge}=person);
} catch(e){}
personName,personBar,personAge //m,undefined,undefined

参数上下文匹配
在函数参数列表中也可以进行解构赋值，对参数的解构赋值不会影响arguments对象，但可以在函数签名中声明在函数体内使用局部变量
let person = {
	name: 'm',
	age:  20
};
function printPerson(foo, {name, age}, bar){
	console.log(arguments)
	console.log(name,age)
}
function printPerson(foo, {name:personName, age: personAge}, bar){
	console.log(arguments)
	console.log(personName,personAge)
}
printPerson('1st',person,'2nd')
// ['1st',{name:'Matt',age:27},'2nd']
// 'Matt',27
printPerson2('1st',person,'2nd')
// ['1st',{name:'Matt',age:27},'2nd']
// 'Matt',27




创建对象
1.工厂模式
function createPerson(name,age,job){
	let o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.f = function(){
		console.log(this.name);
	};
	return o
}
let person1  = createPerson('nicholas',29,'sof')
这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题(即新创建的对象是什么类型)

构造函数模式
es中的构造函数是用于创建特定类型对象的。像object和Array这样的元素构造函数，运行时可以直接在执行环境中使用。
当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法
工厂模式的例子使用构造函数可以这样写
function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.f  = function(){
		console.log(this.name);
	};
}
let person1 = new Person('no',20,'sof')
let person2 = new Person('non',20,'sof')
实际上Person内部的代码和createPerson基本是一样的，只是有如下区别
1没有显示的创建对象
2属性和方法直接赋值给了this
3没有return

要创建Person的实例，应使用new操作符，以这种方式调用构造函数会执行如下操作
1.在内存中创建一个新对象
2.这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性
3.构造函数内部的this被赋值为这个新对象（即this指向新对象
4.执行构造函数内部的代码（给新对象添加属性
5.如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象
p1和p2分别保存这person的不同实例。这两个对象都有一个constructor属性指向person
person1.constructor === Person //true
person2.constructor === Person //true
constructor 本来是用于标识对象类型的，不过一般认为instanceof操作符是确定对象类型更可靠的方式。前面例子中的每个对象
都是Object的实例，同时也是Person的实例，如下面调用instanceof操作符的结果所示：
Person1 instanceof Object //true
Person1 instanceof Person //true
person2 instanceof Object //true
person2 instanceof Person //true
p1,p2之所以也被认为是Object的实例，是因为所有自定义对象都继承自Object
构造函数不一定要写成函数声明的形式，赋值给变量的函数表达式也可以表示构造函数。
在实例化时，如果不想传参，那么构造函数后面的括号可加可不加，只要有new操作符，就可以调用相应的构造函数。

构造函数也是函数
唯一的区别就是调用的方式不同，并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new操作符调用就是构造函数，
而new操作符调用的函数就是普通函数，比如前面的例子中定义的Person可以像下面这样调用
//作为构造函数
let person = new Person('nicholas',20,'sofe')
person.f() //nicholas
//作为函数调用
Person('gg',28,'doc') //添加到window对象
window.f() //gg
//在另一个对象的作用域中调用
let o = new Object();
Person.call(o,'kristen',22,'nurse')
o.f() //kristen

这个例子一开始展示典型的构造函数调用方式，即使用new操作符创建一个新对象，然后是普通函数的调用方式，这时候没有使用
new操作符调用Person()，结果会将属性和方法添加到window对象。这里要记住，在调用一个函数而没有明确设置this的情况下
（即没有作为对象的方法调用，或者没有使用call()/apply()调用），this始终指向Global对象(在浏览器中就是window对象)
因此在上面的调用之后，window对象上就有了一个f方法，调用它会返回gg，最后展示的调用方式是通过call()/apply调用函数
同时将特定对象指定为作用域。这里的调用将对象o指定为Person内部的this值，因此执行完函数代码后，所有属性和sayName方法
都会被添加到对象o上面。

构造函数的问题
构造函数的主要问题在于，其定义的方法会在实例上都创建一遍。因此对于前面的例子而言，p1和p2都有f方法，但这两个方法
不是同一个function实例。es中的函数是对象，因此每次定义函数时，都会初始化一个对象，逻辑上讲，这个构造函数实际上是这样的
function Person(name,age,job){
	this.name=name;
	...
	this.f = new Function('console.log(this.name)')//逻辑等价
}
以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新function实例的机制是一样的。因此不同实例上
的函数虽然同名却不相等。
p1.f == p2.f //false

因为都是做一样的事，所以没必要定义两个不同的function实例，况且，this对象可以把函数与对象的绑定推迟到运行时。
要解决这个问题，可以把函数定义转移到构造函数外部
function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.f = f
}
function f(){
	console.log(this.name)
}
这样虽然解决了相同逻辑的函数重复定义问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。
如果这个对象需要多个方法，那么就要在全局作用域定义多个函数这会导致自定义类型引用的代码不能很好地聚集在一起
这个新问题可以通过原型模式来解决。

原型模式
每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享属性和方法，实际上，这个对象
就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数
中直接赋给对象实例的值，可以直接赋值给他们的原型

虽然不是所有实现都对外暴露了[[Prototype]],但可以使用isPrototypeOf()方法确定两个对象之间的这种关系。
本质上isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true，如下
Person.prototype.isPrototypeOf(p1) //true
Person.prototype.isPrototypeOf(p2) //true
这里通过原型对象调用isPrototypeOf()方法检查了p1和p2，因为这两个例子内部都有链接指向Person.prototype,所以结果
都返回true。
es的Object类型有一个方法叫Object.getPrototypeOf(),返回参数的内部特性[[Prottype]]的值
Object.getPrototypeOf(person1) == Person.prototype //true
Object.getPrototypeOf(person1).name //'nicholas'

第一行代码简单确认了Object.getPrototypeOf()返回的对象就是传入对象的原型对象。第二行代码则取得了原型对象上name属性的值
即nicholas，使用object.getPrototypeOf()可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要。

Object还有一个setPrototypeOf方法，可以想实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系
为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型
let biped = {
	numLegs: 2
};
let person = Object.create(biped)
person.name = 'm'
person.name //m
person.numLegs //2
Object.getPrototypeOf(person)===biped //true

原型层级
在通过对象访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，
则返回该名称对应的值，如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，在返回对应的值

虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值，如果在实例上添加了一个原型对象中同名的属性，那就会在
实例上创建这个属性，这个属性会遮住原型对象上的属性。
即使在实例上把这个属性设置为null，也不会恢复它和原型的联系。不过使用delete操作符可以安全删除实例上的这个属性，
从而让标识符解析过程能够继续搜索原型对象。

hasOwnProperty方法用于确定某个属性是在实例上还是在原型对象上，这个方法是继承自object的，会在属性存在于调用它的对象实例上时返回true

原型和in操作符
有两种方式使用in操作符，单独使用和for-in循环中使用。在单独使用时，in操作符会在可以通过对象访问指定属性时返回true，
无论该属性是在实例上还是在原型上。

function Person(){}
Person.prototype.name = 'n';
let p1 = new Person();
p1.hasOwnProperty('name') ; //false
'name' in p1; //true
p1.name = 'gg'
p1.hasOwnProperty('name'); //true
'name' in person1; //true

如果要确定某个属性是否在原型上，则可以像下面这样同时使用hasOwnProperty()和in操作符
function hasPrototypeProperty(object, name){
	return !object.hasOwnProperty(name)&&(name in object);
}
只要通过对象可以访问，in操作符就返回true，而hasOwnProperty()只有属性存在于实例上时才返回true，因此，只要in操作符
返回true且hasOwnProperty返回false，就说明该属性是一个原型属性。

在for-in循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举
([[Enumerable]]特性被设置为false)属性的实例属性也会在for-in循环中返回，因为默认情况下开发者定义的属性都是可枚举的
要获得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举
属性名称的字符串数组，比如：
function Person(){}
Person.prototype.name = 'n'
Person.prototype.age= 28
Person.prototype.f = function(){
	console.log(this.name)
}
let keys = Object.keys(Person.prototype) //[ 'name', 'age', 'f' ]

如果像列出所有实例属性，无论是否可枚举，都可以使用Object.getOwnPropertyNames():
let keys=Object.getOwnPropertyNames(Person.prototype); //[constructor,name,age,job,sayName]
注意，返回结果中包含一个不可枚举的属性constructor。Object.keys()和Object.getOwnPropertyNames()在适当的时候都可用来代替for-in循环

属性枚举顺序
for-in循环和object。keys的枚举顺序是不确定的，取决于js引擎，可能因浏览器而异
object.getOwnPropertyNames(),object.getOwnPropertySymbols()和object.assign()的枚举顺序是确定性的，先以升序枚举数值建
然后以插入顺序枚举字符串和符号键，在对象字面量中定义的键以他们逗号分隔的顺序插入
let k1 = Symbol('k1'), k2 = Symbol('k2')
let o = {
	1:1,
	first: 'first',
	[k1]:'sym2'
	second: 'second',
	0:0
};
o[k2] = 'sym2'
o[3] = 3
o.third = 'third'
o[2] = 2
Object.getOwnPropertyNames(o)//['0','1','2','3','first','second','third']
Object.getOwnPropertySymbols(o) // [Symbol(k1),Symbol(k2)]

对象迭代
Object.values()和Object.entires()接收一个对象，返回他们内容的数组。Object.values()返回对象值的数组，Object.entries返回键值对数组
例子
const o = {
	foo: 'bar',
	baz: 1,
	qux: {}
}
Object.values(o) //['bar',1,{}]
Object.entries(o) //[['foo','bar'],['baz',1],['qux',{}]]
非字符串属性会被转换为字符串输出，这两个方法执行对象的浅复制


原型的动态性
因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来
例子：
let friend = new Person()
Person.prototype.sayHi = function(){
	console.log('hi')
}
friend.sayHi() //hi

原型的问题
弱化了像构造函数传递初始化参数的能力，会导致所有实例默认都去取得相同的属性值。虽然这会带来不便，但还表示原型最大的问题，
最主要的问题源自它的共享特性。


继承
原型链
。。。

类
类定义与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用class关键字加大括号
类声明
class Person {}
类表达式
const Animal = class {}
与函数表达式类似，类表达式在他们被求值前也不能引用。不过与函数定义不同的是，虽然，函数声明可以提升，但类定义不能

类构造函数
constructor关键字用于在类定义快内部创建类的构造函数。方法名constructor会告诉解释器在使用new操作符创建类的新实例时，
应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。
实例化
使用new操作符实例化Person的操作等于使用new调用其构造函数，唯一可感知的不同之处就是，js解释器知道使用new和类
意味着应该使用constructor函数进行实例化。
使用new调用类的构造函数会执行如下操作。
1.在内存中创建一个新对象
2.这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性
3.构造函数内部的this被赋值为这个新对象(即this指向新对象)
4.指向构造函数内部的代码(给新对象添加属性)
5.如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象

例子
class Animal{}
class Person{
	constructor(){
		console.log('person ctor')
	}
}
class Vegetable{
	constructor(){
		this.color = 'orange'
	}
}

let a = new Animal();
let p = new Person(); //Person ctor
let v = new Vegetable()
console.log(v.color) //orange

类实例化时传入的参数会用作构造函数的参数，如果不需要参数，则类名后面的括号也是可选的:
class Person{
	constructor(name){
		console.log(arguments.length);
		this.name = name || null;
	}
}

默认情况下，类构造函数会在执行之后返回this对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的this对象，
那么这个对象会被销毁。不过，如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，
因为这个对象的原型指针并没有被修改
class Person{
	constructor(override){
		this.foo = 'foo';
		if(override){
			return{
				bar: 'bar'
			};
		}
	}
}
let p1 = new Person(), p2 = new Person(true)
console.log(p1) //Person{foo:'foo'}
console.log(p1 instanceof Person) //true

console.log(p2) //{bar:'bar'}
consoel.log(p2 instanceof Person) //false
类构造函数与构造函数的主要区别是，调用类构造函数必须使用new 操作符，而普通构造函数如果不使用new调用，
那么就会以全局的this(通常是window)作为内部对象


class Person {
	constructor() {
		// 添加到this的所有内容都会存在于不同的实例上
		this.locate = ()=> console.log('instance', this);
	}
	
	// 定义在类的原型对象上
	locate() {
		console.log('prototype', this);
	}
	
	// 定义在类本身上
	static locate() {
		console.log('class', this);
	}
}

let p = new Person();
p.locate();  //instance, Person {}
Persson.prototype.locate(); //prototype, { constructor: ...}
Person.locate(); //class, class Person {}

代理与反射
默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。
因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。

代理是使用Proxy构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。
缺少任何一个参数都会抛出Typeerror，要创建空代理，可以传一个简单的对象字面量作为处理程序对象，
从而让所有操作畅通无阻地抵达目标对象。
如下，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可以感知不同的就是代码中操作的是代理对象。

const target = {
	id: 'target'
};

const handler = {};
const proxy = new Proxy(target, handler);

target.id //target
proxy.id //target
//给目标属性赋值会反映在两个对象上，因为两个对象访问的是同一个值
target.id = 'foo';
target.id //foo
proxy.id //foo
//给代理属性赋值会反映在两个对象上，因为这个赋值会转移到目标对象
proxy.id = 'bar';
target.id //bar
proxy.id //bar

// hasOwnProperty()方法在两个地方都会应用到目标对象
// 都会应用到目标对象
target.hasOwnProperty('id'); //true
proxy.hasOwnProperty('id'); // true

//Proxy.prototype是undefined
// 因此不能使用instanceof操作符
target instanceof Proxy // TypeError
proxy instanceof Proxy // TypeError

//一个相等可以用来区分代理和目标
target === proxy //false


定义捕获器
使用代理的主要目的是可以定义捕获器(trap).
它就是在处理程序对象中定义的基本操作的拦截器。
每个处理程序对象可以包含零个或者多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象调用。
每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。

例如，定义一个get（）捕获器，在es操作以某种形式调用get()时触发
下面的例子定义了一个get()捕获器
const target  = {
	foo: 'bar'
}
const handler = {
	//捕获器在处理程序对象中以方法名为建
	get(){
		return 'handler override';
	}
}

const proxy = new Proxy(target, handler)

这样通过代理对象执行get操作时，就会触发定义的get捕获器
target.foo //bar
proxy.foo //handler override

捕获器参数和发射API
所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为
比如，get()捕获器会接收到目标对象，要查询的属性和代理对象三个参数

const traget = {
	foo: 'bar'
};

const handler = {
	get(trapTarget, property, receiver) {
		console.log(trapTarget === target);
		console.log(property);
		console.log(receiver === proxy);
	}
};

const proxy = new Proxy(target, handler);
proxy.foo;
// true
// foo
// true

函数声明会整体提升到顶部
函数表达式只在执行到那行后才能使用




Promise
进度通知
一种实现方式是扩展Pormise类，为它添加notify()方法
如下
class TrackablePromise extends Promise {
	constructor(executor) {
		const notifyHandlers = [];
		super((res,rej)=> {
			return executor(res, rej, (status) => {
				notifyHandlers.map((handler) => handler(status));
			});
		});
		this.notifyHandlers = notifyHandlers;
	}
	notify(notifyHandler) {
		this.notifyHandlers.push(notifyHandler);
		return this;
	}
}
这样TrackablePromise就可以在执行函数中使用notify函数了
let p = new TrackablePromise((res,rej,notify)=> {
	function countdown(x) {
		if(x>0) {
			notify(`${20*x}% remaining`);
			setTimeout(()=>countdown(x-1), 1000);
		} else {
			resolve();
		}
	}
	countdown(5);
});

这个期约会连续5次递归地设置1000毫秒的超时，每个超时回调都会调用notify()并插入状态值。
假设通知程序简单地如上那样写
p.notify((x)=>setTimeout(conosle.og, 0, 'progress:', x));
p.then(()=>setTimeout(consoel.log, 0, 'completed'));

// 约1秒后 80% remaining
// 约2秒后 60% remaining
...
// 约5秒后 completed

notify函数会返回期约，所以可以连缀调用，连续添加处理程序，多个处理程序会针对收到的每条消息分别执行一遍
p.notify((x)=>setTimeout(consoel.log, 0, 'a:', x))
 .notify((x)=>setTimeout(console.log,0,'b:',x));
p.then(()=>setTimeout(consoel.log, 0, 'completed'));

//约1秒后 a: 80% remaining
//约1秒后 b: 80% remaining
...
//约5秒后 completed


异步函数（async/await)
使用async关键字可以让函数具有异步特征，但是总体上代码依然是同步求值的，而在参数或者闭包方面，异步函数仍然
具有普通js函数的正常行为。正如下面的例子所示，foo函数仍然会在后面的指令之前被求值：
async function foo() {
	console.log(1);
}

foo();
console.log(2);
// 1
// 2

不过，异步函数如果使用return关键字返回了值(如果没有return则会返回undefined)， 这个值会被Promise.resolve()
包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约。
async function foo() {
	console.log(1);
	return 3;
	// 直接返回一个期约对象也是一样的
	// return Promise.resolve(3);
}

// 给返回的期约添加一个解决处理程序
foo().then(console.log);
console.log(2);
//1
//2
//3


await
因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。
使用await可以暂停异步函数代码的执行，等待期约解决。

js在运行是碰到await关键字时，会记录在哪里暂停执行。等到await右边的值可用了，
js运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。
因此，即使await后面跟着一个立即可用的值，函数其余部分也会被异步求值，如：
async function(){
	console.log(2);
	await null;
	console.log(4);
}

consoel.log(1);
foo();
console.log(3);
//1
//2
//3
//4


BOM
BOM的核心是window对象，window对象在浏览器中有两重身份，一个是es中的Global对象，另一个就是浏览器窗口的js
接口。这意味着网页中定义的所有对象，变量和函数都以window作为器Global对象。

GLobal作用域
因为window对象被复用为Es的Global对象，所以通过var声明的所有全局变量和函数都会变成window对象的属性和方法


窗口位置与像素比
现代浏览器提供了screenLeft和screenTop属性，用于表示窗口相当于屏幕左侧和顶部的位置，返回值的单位是css像素
可以使用moveTo和moveBy方法移动窗口，这两个方法都接受了两个参数，前者接受要移动到的位置的绝对坐标xy，
后者接受相对当前位置在两个方向上移动的像素
window.moveTo(0,0) // 把窗口移动到左上角
window.moveBy(0,100) // 把窗口向下移动100像素
如果一个手机屏幕的物理分辨率可能是1920X1080，，但是像素可能非常小，所以浏览器需要将分辨率降为较低的
逻辑分辨率，比如640X320.这个物理像素和css像素之间的转换比率由window.devicePixelRatio属性提供。
对于分辨率从1920x1080转换为640x320的设备，这样一来，12像素(css像素)的文字实际上就会用36像素的物理像素来显示。


窗口大小
innerWidth，innerHeight，outerWidth和outerHeight
前者返回浏览器窗口自身大小，后者返回浏览器窗口页面视口的大小（不包含浏览器边框和工具栏)

视口位置
相对于视口滚动的距离的属性有两对，返回相等的值：window.pageXoffset/window.scrollX和window.pageYoffset/window.scrollY
相对于当前视口向下滚动100像素
window.scrollBy(0 , 100);
滚动到页面左上角
window.scrollTo(0, 0);
这几个方法也都接受一个scrroll字典，除了提供偏移值，还可以通过behavior属性告诉浏览器是否平滑滚动
// 正常滚动
window.scrollTo({
	left: 100,
	top: 100,
	behavior: 'auto'
})

// 平滑滚动
window.scrollTo({
	left: 100,
	top: 100,
	behavior: 'smooth'
});

h5通过给所有元素新增classList属性为类的增删提供了简单也更安全的实现方式。
// 删除 disabled类
div.classList.remove('disabled')
// 添加 current类
div.classList.add('current');
// 如果有ac类删除，没有则添加
div.classList.toggle('ac');
// 检测类名
if(div.classList.contains('ss'))

焦点管理
h5增加了辅助dom焦点管理的功能，首先是document.activeElement,始终包含当前拥有焦点的dom元素。
页面加载时，可以通过用户输入(按tab会在代码中使用focus（）方法)让某个元素自动获得焦点
let btn = document.gid('b');
b.focus()
document.activeElement === btn //true
默认情况下，document.activeElement在页面刚加载完之后会设置为document.body。而在页面完全加载之前
它的值为null
其次是document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点:
let btn = document.gid('b');
b.focus()
document.hasFocus() //true


元素尺寸
偏移尺寸
offsetHeight:元素在垂直方向上占用的尺寸，包括高度，水平滚动条高度和上下边框的高度
offsetLeft: 元素做边框外侧距离包含元素左边框内测的像素数
offsetTop: 元素上边框外侧距离包含元素上边框内测的像素数
offsetWidth: 元素在水平方向上占用的像素尺寸，包括它的宽度，垂直滚动条宽度，和左右边框的宽度

客户端尺寸
包含元素内容机器内边距所占用的空间，客户端尺寸只有两个相关属性:clientWidth和clientHeight。
前者是内容区域宽度加左右内边距

滚动尺寸
scrollHeight，没有滚动条出现，元素内容的总高度
scrollLeft， 内容区左侧隐藏的像素数，设置它可以改变元素的滚动位置
scrollTop，内容区顶部隐藏的像素数，设置它可以改变元素的滚动位置


currentTarget是事件绑定在的元素
target是触发事件的元素
此时this和currenTarget 一样



await 比 promise 好的证明
1. 简洁
由示例可知，使用Async/Await明显节约了不少代码。我们不需要写.then，
不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。
这些小的优点会迅速累计起来，这在之后的代码示例中会更加明显。

2. 错误处理

Async/Await让try/catch可以同时处理同步和异步错误。在下面的promise示例中，
try/catch不能处理JSON.parse的错误，因为它在Promise中。我们需要使用.catch，
这样错误处理代码非常冗余。并且，在我们的实际生产代码会更加复杂。

const makeRequest = () => {
  try {
    getJSON()
      .then(result => {
        // JSON.parse可能会出错
        const data = JSON.parse(result)
        console.log(data)
      })
      // 取消注释，处理异步代码的错误
      // .catch((err) => {
      //   console.log(err)
      // })
  } catch (err) {
    console.log(err)
  }
}
使用aysnc/await的话，catch能处理JSON.parse错误:

const makeRequest = async () => {
  try {
    // this parse may fail
    const data = JSON.parse(await getJSON())
    console.log(data)
  } catch (err) {
    console.log(err)
  }
}

3. 条件语句

下面示例中，需要获取数据，然后根据返回数据决定是直接返回，还是继续获取更多的数据。

const makeRequest = () => {
  return getJSON()
    .then(data => {
      if (data.needsAnotherRequest) {
        return makeAnotherRequest(data)
          .then(moreData => {
            console.log(moreData)
            return moreData
          })
      } else {
        console.log(data)
        return data
      }
    })
}
这些代码看着就头痛。嵌套（6层），括号，return语句很容易让人感到迷茫，
而它们只是需要将最终结果传递到最外层的Promise。

上面的代码使用async/await编写可以大大地提高可读性:

const makeRequest = async () => {
  const data = await getJSON()
  if (data.needsAnotherRequest) {
    const moreData = await makeAnotherRequest(data);
    console.log(moreData)
    return moreData
  } else {
    console.log(data)
    return data   
  }
}

4. 中间值

你很可能遇到过这样的场景，调用promise1，使用promise1返回的结果去调用promise2，然后使用两者的结果去调用promise3。你的代码很可能是这样的: 

1
2
3
4
5
6
7
8
9
const makeRequest = () => {
  return promise1()
    .then(value1 => {
      return promise2(value1)
        .then(value2 => {       
          return promise3(value1, value2)
        })
    })
}
如果promise3不需要value1，可以很简单地将promise嵌套铺平。
如果你忍受不了嵌套，你可以将value 1 & 2 放进Promise.all来避免深层嵌套：

const makeRequest = () => {
  return promise1()
    .then(value1 => {
      return Promise.all([value1, promise2(value1)])
    })
    .then(([value1, value2]) => {     
      return promise3(value1, value2)
    })
}
这种方法为了可读性牺牲了语义。除了避免嵌套，并没有其他理由将value1和value2放在一个数组中。

使用async/await的话，代码会变得异常简单和直观。

const makeRequest = async () => {
  const value1 = await promise1()
  const value2 = await promise2(value1)
  return promise3(value1, value2)
}